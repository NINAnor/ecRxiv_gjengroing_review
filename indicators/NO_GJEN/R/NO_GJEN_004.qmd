---
title: "Enchroachment LiDAR"
format: 
  html:
    embed-resources: true
author:
  - name: Ida M. Mienna              # Enter name
    email: ida.mienna@nina.no  # Enter email
    affiliations:
      - id: myID
        name: The Norwegian Institute for Nature Research (NINA) # Enter affiliations
  - name: Zander Venter              #  Enter subsequent authors like this, or remove if not relevant
    affiliations:
      - ref: myID               # To reuse affiliations referecen the id like this
date: August 12, 2024 # Enter date 
callout-icon: false
---

<!--# This is a template for how to document the indicator analyses. Make sure also to not change the order, or modify, the headers, unless you really need to. This is because it easier to read if all the indicators are presented using the same layout. If there is one header where you don't have anything to write, just leave the header as is, and don't write anything below it. If you are providing code, Be careful to annotate and comment on every step in the analysis. Before starting it is recommended to fill in as much as you can in the metadata file. This file will populate the initial table in your output.-->

<!--# Load all you dependencies here -->

```{r setup}
#| include: false
library(knitr)
library(sf)
library(tidyverse)
library(gridExtra)
library(kableExtra)
library(RColorBrewer)
library(flextable)
library(here)

# Set global variable defining whether you want to run everything from scratch (very long runtime) or use pre-exported data (short runtime)
runFromScratch <- FALSE

knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)


```

```{r source}
#| echo: false
source(here::here("R/_common.R"))

here::here()
```

```{r}
#| echo: false
meta <- readxl::read_xlsx("../metadata.xlsx")
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
name <- year <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

<!--# The following parts are autogenertaed. Do not edit. -->

::: {layout-ncol="3"}
```{r}
#| echo: false
#| results: asis
status(st)
```

::: {.callout-note style="background: cornsilk;"}
## Recomended citation

`r paste(auth, year, name, "v.", version, "ecRxiv", url, sep=" ")`
:::

::: {.callout-note style="background: khaki;"}
## Version

`r version`
:::
:::

```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kbl(col.names = NULL) 

```

# Gjengroing

<br />

<br /> <br />

<hr />

## 1. Introduction

The Norwegian word "gjengroing" is directly translated to "regrowing" in English. The gjengroing indicator describes the regrowth of woody vegetation (trees and bushes) in open ecosystems (open wetland, naturally open and open semi-natural areas) across Norway. We will use a spatial reference approach where reference areas define good or optimal vegetation regrowth heights.

The workflow spans two platforms including RStudio and Google Earth Engine (GEE). To reproduce this workflow you will need a GEE account and access to the NINA RStudio and R/GeoSpatialData servers.

## 2. About the underlying data

We rely on the following datasets:

-   [NiN nature type polygons](https://kartkatalog.miljodirektoratet.no/Dataset/Details/2031) are used to identify reference areas with good ecological condition.
-   [Nasjonalt grunnkart](https://nibio.brage.unit.no/nibio-xmlui/handle/11250/3120510) is used as the population sample for wetland. The population sample are the areas used to determine ecological condition relative to the reference areas. We also use the grunnkart-data to identify forest for defining the lower limit of ecological condition index (i.e. poor condition).
-   GRUK dataset is used population sample for natural open areas. as The dataset is based on a method for area-representative monitoring of dry calcareous grassland (åpent grunnlendt kalkmark).
-   [ASO dataset](https://www.miljodirektoratet.no/ansvarsomrader/overvaking-arealplanlegging/miljoovervaking/overvakingsprogrammer/natur-pa-land/semi-naturlig-eng/) is used as population sample for semi-natural areas. This dataset is based on a method for area-representative monitoring of semi-natural grasslands.
-   LiDAR-derived digital elevation model from Kartverket's [høydedata](https://hoydedata.no/LaserInnsyn/). This includes both a terrain (DTM) and surface model (DSM). We calculate the canopy height model (CHM=DSM-DTM) to get the height of objects above the ground. From this we remove buildings, and what remains is vegetation - mostly trees but also some bushes or smaller woody plants.
-   [FKB building footprints](https://kartkatalog.geonorge.no/metadata/fkb-bygning/8b4304ea-4fb0-479c-a24d-fa225e2c6e97) are used to isolate vegetation in the LiDAR height data.
-   A [European satellite-based map](https://www.nature.com/articles/s41893-020-00609-y) of forest clear cuts is used for identifying grunnkart forest patches in near-climax successional stages.
-   The regional delineation for Norway (five regions; Nord-Norge, Midt-Norge, Vestlandet, Østlandet, Sørlandet) are used for stratifying reference (good condition) and forest (poor condition) heights (together with bioclimatic zones) and aggregating and reporting gjengroing condition values.
-   [Bioclimatic zones](https://artsdatabanken.no/Pages/181901/Bioklimatiske_soner). We use this dataset (together with the regions) to stratify reference and forest heights by bioclimatic (also referred to as vegetation/climatic) zones.
-   The [SSB 10km and 50km grids](https://kartkatalog.geonorge.no/metadata/statistiske-rutenett/558c4995-9c55-4686-8143-f329f87ce33f) is used for visualization purposes.

### 2.1 Spatial and temporal resolution

The index will cover the mainland of Norway. The analysis will be stratified by (1) våtmark (wetland), (2) åpen (natural open), and (3) semi-naturlig (semi-natural) ecosystems below the forestline. The LiDAR data cover a range of years and therefore the indicator represents conditions for circa 2010 to 2021.

Temporal coverage: Circa 2010 to 2023. This is a single snapshot and not a change analysis. In the future, when LiDAR data has been repeated across the country, it may be possible to do a change assessment.

### 2.2 Original units

The original units for ecological condition are meters. This is the height of the vegetation within reference, polygon and forest areas.

### 2.3 Additional comments about the dataset

<!--# Text here -->

## 3. Indicator properties

### 3.1. ECT

<!--# Describe the rationale for assigning the indicator to the ECT class -->

ECT: Structural state characteristic

Ecosystem: Våtmark, naturlig åpne and semi-natural ecosystems.

Egenskap: Funksjonell sammensetning innen trofiske nivåer.

### 3.2. Ecosystem condition characteristic

<!--# Describe the ecosystem condition characteristic represneted in the indicator. See 10.3897/oneeco.6.e58218 for information on what these characteristics might be. -->

### 3.3. Other standards

<!--# Add text about other spesific standards, e.g. natinoal standards, and how the indicator relates to these -->

### 3.4. Collinearities with other indicators

<!--# Describe known collinearities with other metrices (indicators or variables) that could become problematic if they were also included in the same Ecosystem Condition Assessment as the indicator described here. -->

There is possibly a collinearity with the [primary production indicator](#NDVI-indicator-natopen) (primærproduksjon). The primary production indicator uses the normalized difference vegetation index (NDVI) as a proxy for vegetation production. NDVI can be correlated with vegetation height and consequently yield similar results to the LiDAR-based gjengroing indicator.

## 4. Reference condition and values

### 4. 1. Reference condition

<!--# Define the reference condition (or refer to where it is defined). Note the destinction between reference condition and reference values 10.3897/oneeco.5.e58216  -->

The reference state is defined as one where open ecosystems are indeed open, with little to no woody encroachment. For natural ecosystems this reflects a state where climate warming, wetland drainage, and alien species etc have not led to any net loss of these nature types and their internal functioning. For semi natural ecosystems it reflects a state where traditional husbandry is keeping the ecosystems open due to grazing and hay making.

### 4. 2. Reference values

#### 4.2.1 Minimum and maximum values

<!--# Describe the reference values used to set the lower and upper limits on the normative indicator scale. Why was the current option chosen and how were the reference values quantified? If the reference values are calculated as part of the analyses further down, please repeat the main information here. -->

The methodology used to calculate the *gjengroing* indicator is outlined in the schematic below. The workflow in the schematic is conducted for all reference and population polygons in Norway and repeated for each ecosystem type (våtmark, naturlig åpne og semi-naturlig), respectively. The indicator values are aggregated to a 50km grid and regional level at the end. The individual steps are discussed in turn in the following subsections.

```{r enc-workflow, fig.cap="Schematic illustration of how the encroachment indicator is calculated. The lower bound for poor condition is set by LiDAR heights from mature forest surrounding the population polygon. The upper bound for good condition is set by regional median LiDAR heights within NiN polygons in the same bioclimatic-elevation zone as the population polygon.", out.width='70%', echo=FALSE}
knitr::include_graphics("../img/gjengroing_schematic.jpg")
getwd()
```

The NiN polygons including "Våtmark", "Naturlig åpne områder under skoggrensa" and "Semi-naturlig mark" with good ecological condition are used to define a reference gjengroing state. We use the aggregated "Tilstand" variable assigned to each NiN polygon. The 50th percentile of LiDAR-derived vegetation heights within these polygons is used to define the upper limit (ie. 1) of the scaled indicator value. We cannot define local reference values based on proximity, because the NiN polygons are spatially biased and not close to all population polygons. Therefore we calculate regional reference values using regions and bioclimatic zones as stratification. We calculate the mean reference value for each unique combination of region-bioclimatic zone. When calculating the index for each population polygon, the reference value is inherited from the region-bioclimatic zone it falls within.

Once we have the reference vegetation height for a given ecosystem type and region-bioclimatic zone, we need to define the minimum (or worst/bad) condition. We use the 90th percentile of LiDAR-derived vegetation heights within "nasjonalt grunnkart skog" polygons to define a climax vegetation successional stage where gjengroing is at its most extreme, and thus what is the poor ecological condition for naturally open areas. In order not to include forest patches that have recently been harvested, we mask out any forest which has been clear-cut since 1986. Here, 1986 is a hard limit defined by the clear-cut dataset which was based on Landsat imagery. Therefore we can be assured that we are measuring forest that is at least 35 years old. For the natural open areas, however, we set a threshold (0.8 m) for the minimum condition (explained below).

To define the ecological condition of the population polygon, we measure 50th percentile of LiDAR-derived vegetation height. Population polygons should be approximately compatible with the NiN ecosystem types, and we have thus used three different data sources for the three different ecosystem types. For våtmark, we use types in nasjonalt grunnkart defined as Klasse 7 Våtmark. For åpen, we have used the GRUK dataset. For semi-natural, we have used the ASO dataset.

The vegetation height percentiles are then scaled to between 0 and 1 using a sigmoid transformation [Oliver at al. (2021)](https://www.sciencedirect.com/science/article/pii/S1470160X21000066).

#### 4.2.2. Threshold value for defining *good ecological condition (if relevant)*

<!--# Describe the different reference values here and the justification for using these -->

#### 4.2.3. Spatial resolution and validity

<!--# Describe the spatial resolution of the reference values. E.g. is it defined as a fixed value for all areas, or does it vary. Also, at what spatial scale is the reference values valid? For example, if the reference value has a regional resolution (varies between regions), it might mean that it is only valid and correct to use for scaling local variable values that are first aggregated to regional scale. However, sometimes the reference value is insensitive to this and can be used to scale variables at the local (e.g. plot) scale.  -->

## 5. Uncertainties

<!--# Describe the main uncertainties or sources of error in the indicator or the underlying data. -->

The calculation of the indicator involves many small decisions which can have significant effects on the resulting conditions cores. **Therefore in the future it would be good to perform sensitivity analyses with each decision to test the effect on the outcome.** The decisions which would benefit from further exploration include:

-   **Selection of the reference and population areas.** Here we were limited to using NiN and AR5 because these are arguably the best datasets currently available for this exercise. However, both NiN and AR5 are spatially and thematically biased in some ways. Therefore, it may be worth exploring alternative datasets in the future. NiN polygons are biased towards low lying areas which are generally warmer and more productive. For a given bioclimatic-elevation strata, this could lead to higher reference values for vegetation height than one would expect with a representative reference sample. This could consequently result in high elevation population polygons appearing to have very good condition because they are being compared with (relatively) high productivity polygons in the same strata.

    -   **This is technically still an issue.**

-   **Definition of good condition states in NiN data.** Here we used the overall "tilstand" score for each NiN reference polygon. However, the overall score is a combination of several sub-scores that may or may not be relevant for ecological condition. For instance, ditches or wheel marks in wetlands is a common condition score in NiN, however it is debatable as to whether this should be considered a part of ecological condition. Therefore it may be beneficial to attempt repeating the indicator calculation using sub-categories of "tilstand" in the NiN data.

    -   **This will only make sense for semi-naturlig and naturlig åpen as gjengroing is one of the "tilstand"-indicators.**

-   **Definition of climax successional stage for tree regrowth.** Here we use the 50th percentile of LiDAR-derived tree heights in AR5 forest polygons that have not been harvested since 1986. This defines the zero on the scaled indicator score. The resulting indicator scores will vary widely depending on how you define this zero-point. Therefore, testing different definitions (i.e. tree height percentiles) may be important.

    -   **This should be less uncertain now as we use the 90th percentile instead.**

-   **Quantifying regional vs local references for poor and good condition.** For good condition, we used NiN polygons and were restricted to these due to lack of better data. However, for poor condition we use climax successional stage for trees (as explained above) within 200m of each population polygon. For polygons with no surrounding forest, we impute with regional reference values (mean of forest height in elevation-bioclimatic zone). The choice of 200m buffer zone was largely based on computational limitations. Calculating the average LiDAR vegetation height within 200m of nearly 2 million complex polygons takes time, even in GEE. It may make more ecological sense to define a larger buffer zone to use for defining reference for poor condition. However, longer processing times need to be expected.

    -   **This should now be less of an issue as the reference for poor condition is 90th percentile forest height within each region-bioclimatic zone strata.**

-   **Quantification of uncertainty around indicator scores.** Here we used the standard deviation in the vegetation heights for reference (NiN) polygons within each region to quantify the uncertainty around scaled indicator scores. We did this because the method used in `eaTools::ea_spread()` function is a bootstrapping approach which resulted in extremely small uncertainty estimates due to the large number of polygons included in our analysis. [In the future, a better method for quantifying uncertainty is needed.](https://github.com/NINAnor/eaTools/issues/17) Perhaps by running sensitivity analyses that test several variations of the points mentioned above can form the basis for quantifying an error margin around indicator values.

    -   **NEEDS TO BE DISCUSSED**

## 6. References

<!--# You can add references manually or use a citation manager and add intext citations as with crossreferencing and hyperlinks. See https://quarto.org/docs/authoring/footnotes-and-citations.html -->

Links to data and resources are provided with hyperlinks in-line.

## 7. Datasets

<!--# Describe the unique datasets seperately under seperate headers (Dataset A, Dataset B, etc.-->

There are several datasets which are used in GEE which will not be imported into the R session here. These datasets have been obtained from the source and ingested into GEE by Zander Venter or Vegar Bakkestuen with the help of Miljødata section at NINA. They include

-   [Nasjonalt grunnkart](https://nibio.brage.unit.no/nibio-xmlui/handle/11250/3120510)
-   [LiDAR-derived digital elevation model from høydedata](https://hoydedata.no/LaserInnsyn/).
-   [FKB building footprints](https://kartkatalog.geonorge.no/metadata/fkb-bygning/8b4304ea-4fb0-479c-a24d-fa225e2c6e97)
-   [European forest clear-cut map](https://www.nature.com/articles/s41893-020-00609-y)
-   Population polygons for naturlig åpen areas (GRUK).

The remaining datasets will be imported into the R session.

### 7.1 Regions

The regional delineation for Norway (five regions) are used for aggregating and reporting gjengroing condition values.

```{r}

regions <- sf::st_read("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Regions/regions.shp")

# Some issues with the letter "ø"
regions$region[regions$id == 3] <- "Østlandet"
regions$region[regions$id == 5] <- "Sørlandet"

regionlvl <- c("Nord-Norge", "Midt-Norge", "Vestlandet", "Østlandet", "Sørlandet")

regions$region <- factor(regions$region, levels=regionlvl)

```

### 7.2 Bioclimatic regions

The [Moen's bioclimatic regions](https://data.artsdatabanken.no//Natur_i_Norge/Natursystem/Beskrivelsessystem/Regional_naturvariasjon/Bioklimatisk_sone) are imported from NINA R/GeoSpatialData/-server.

```{r}

vegclimzonelvl <- c("Lavalpin sone (LA)", "Nordboreal sone (NB)", "Mellomboreal sone (MB)", "Sørboreal sone (SB)", "Boreonemoral sone (BN)")


if(runFromScratch){
  bioclim <- st_read('/data/R/GeoSpatialData/BiogeographicalRegions/Norway_PCA_klima/Converted/Soner2017.shp')
  bioclim <- st_transform(bioclim, "EPSG:4326")
  
  # The file is in tiles. Will therefore dissolve these by Sone_navn
  bioclim <- bioclim %>%
    group_by(Sone_navn) %>%
    summarise(geometry = st_union(geometry))
  
  # Add unique code for each name called KLASSE
  bioclim <- bioclim %>%
    mutate(KLASSE=as.numeric(as.factor(Sone_navn))) %>%
    rename(NAVN="Sone_navn")
  
  bioclim$NAVN <- factor(bioclim$NAVN, levels=vegclimzonelvl)
  
  # Export the file
    st_write(bioclim, '/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Bioclimatic_zones/bioclimzone.shp', append=FALSE)

    } else {
  
  bioclim <- st_read('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Bioclimatic_zones/bioclimzone.shp')

}

```

### 7.3 SSB 10 and 50km grids

The [SSB 10km and 50km grids](https://kartkatalog.geonorge.no/metadata/statistiske-rutenett/558c4995-9c55-4686-8143-f329f87ce33f) are used for visualizing the distribution of available data and for aggregating gjengroing index scores.

```{r}
ssb10km <- st_read('/data/R/GeoSpatialData/Population_demography/Norway_SSB/Original/ssb_10km/ssb10km.shp')%>%
  # mutate the id value so that it aligns with the data coming from GEE
  mutate(SSBID = as.numeric(SSBID)/1000)
# Transform to the correct projection
ssb10km <- st_transform(ssb10km, st_crs(regions))

ssb50km <- st_read('/data/R/GeoSpatialData/Population_demography/Norway_SSB/Original/ssb_50km/ssb50km.shp')%>%
  # mutate the id value so that it aligns with the data coming from GEE
  mutate(SSBID = as.numeric(SSBID)/1000)
# Transform to the correct projection
ssb50km <- st_transform(ssb50km, st_crs(regions))
```

### 7.4 ASO

The [ASO dataset](https://www.miljodirektoratet.no/ansvarsomrader/overvaking-arealplanlegging/miljoovervaking/overvakingsprogrammer/natur-pa-land/semi-naturlig-eng/) is used as population polygons for semi-natural areas. The dataset consists both of open nature types (e.g. slåttemark) and non-open nature types (e.g. hagemark). The types that are non-open will thus be excluded from the dataset before exporting to Google Earth Engine.

```{r}
if(runFromScratch){
  ASO <- st_read("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/ASO/ASO_naturområder_21-23.shp")

ASO <- ASO[ASO$naturtype %in% c("Naturbeitemark", "Semi-naturlig eng", "Slåttemark"),]

st_write(ASO, "/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/ASO/ASO_open.shp")
}


```

### 7.5 Reference data: NiN polygons

NiN polygons are imported here from the NINA servers but are originally imported as a [dataset from Miljødirektoratet](https://kartkatalog.miljodirektoratet.no/dataset/Details/2031). The dataset is here filtered so that it only contains natural open areas under the forest line of wetland, semi-natural land and other natural open areas that do not fit into these two categories (e.g. åpent grunnlendt mark).

```{r}

if(runFromScratch){

  # Function to extra hovedtype
  extract_hovedtype <- function(text) {
    matches <- str_match_all(text, "NA_(.*?)-")
    unique(matches[[1]][, 2])
  }
  
  nin <- st_read('/data/R/GeoSpatialData/Habitats_biotopes/Norway_Miljodirektoratet_Naturtyper_nin/Original/Naturtyper - Miljødirektoratets instruks/Naturtyper_nin_0000_norge_25833_FILEGDB.gdb', layer="naturtyper_nin_omr") %>%
    # Fix any invalid geometries
    mutate(validGeo = st_is_valid(SHAPE)) %>%
    filter(validGeo) %>%
    # Simplify ecosystem names
    mutate(hovedøkosystem = recode(hovedøkosystem, 
                                   "våtmark" = 'Vaatmark',
                                   "skog" = "Skog",
                                   "fjell" = "Fjell",
                                   "semi-naturligMark" = 'Semi-naturlig',
                                   "naturligÅpneOmråderILavlandet" = 'Naturlig aapne',
                                   "naturligÅpneOmråderUnderSkoggrensa" = 'Naturlig aapne'))

  
  # We need to filter out the ecosystems we are not interested in. First, we only include types that are non-alpine by removing the areas that overlap with the bioclimatic zone 'Lavalpin sone (LA)'.
  nin <- st_difference(nin, bioclim[bioclim$NAVN == "Lavalpin sone (LA)",])
  
  # Not all alpine types do overlap with this bioclimatic zone due to the resolution of the bioclimatic zone dataset. Thus, we further need to remove these types. In addition, we remove forested wetland types and semi-natural types.
  nin <- nin %>%
    filter(!(hovedøkosystem %in% c('Skog','Fjell'))) %>% # Remove forest and alpine ecosystem types
    filter(!(naturtype %in% c('Åpen myrflate i lavalpin sone'))) %>% # Alpine
    # Remove nature types that can have a good condition but has a tree cover >10%
    filter(!(naturtype %in% c('Hule eiker', 
                              'Hagemark',
                              'Lauveng',
                              'Saltpåvirket strand- og sumpskogsmark',
                              'Flommyr, myrkant og myrskogsmark',
                              'Grankildeskog',
                              'Svak kilde og kildeskogsmark',
                              'Sørlig kaldkilde',
                              'Kaldkilde under skoggrensa',
                              'Varmekjær kildelauvskog',
                              'Gammel fattig sumpskog',
                              'Rik gransumpskog',
                              'Rik svartorsumpskog',
                              'Kilde-edellauvskog',
                              'Rik gråorsumpskog',
                              'Kalkrik myr- og sumpskogsmark',
                              'Rik vierstrandskog',
                              'Rik svartorstrandskog',
                              'Saltpåvirket svartorstrandskog',
                              'Leirravine' # This type is often not open
                              ))) %>%
    # Get the main ecosystem codes. As there are multiple types in a column, we need to use a function (see above)
    mutate(hovedtype = sapply(ninKartleggingsenheter, function(x) paste(extract_hovedtype(x), collapse = ",")),
           id = identifikasjon_lokalId) %>%
    # Drop polygons with no condition score
    drop_na(tilstand) %>%
    # Only included specific columns
    dplyr::select(id, hovedøkosystem, hovedtype, naturtypeKode, tilstand)
  
# Export the data
    nin %>%
     dplyr::select(id, hovedøkosystem, tilstand) %>%
     st_transform("EPSG:4326") %>%
     st_write('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/NiN/nin_cleaned2.shp', append=FALSE)

}
```

### 7.6 Import data to Google Earth Engine, run GEE **JavaScript code and download data**

-   **Import** **cleaned** **datasets (ASO and NiN data) to Google Earth Engine.**
-   **Run the following GEE JavaScript code by clicking on the hyperlink:** [GEE script](https://code.earthengine.google.com/275819f2dda6caae1f263003684e0c16). When you run the script, then click the Tasks tab in the GEE code editor and run the export tasks. The export files will appear in your Google Drive.
-   **Download the files from your Google Drive to the /data/gjengroing/From_GEE directory:**
    -   'area_cover_grid.csv' - this gives the area coverage of reference data, population data and LiDAR data for each 10x10km SSB grid cell.
    -   'vegHeights_skog_climZoneRegion.csv' - this gives the 90th height percentile for each region-bioclimatic strata.
    -   'vegHeights.zip' - this is a folder with hundreds of CSV files. These files contain the vegetation heights for reference and population over Norway. The exports were split by 50km grid to prevent hitting user memory limits in GEE.

### 7.7 Import Google Earth Engine data

Once you have run the GEE script above, and downloaded the data to the `/From_GEE/` directory, you can proceed with this R workflow.

If not already done manually, extract files from the zipped GEE folder.

```{r}

if(runFromScratch){
  zipped_folder <- list.files("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/",
                            pattern=".zip$",full.names=T)
unzipped_folder <- "/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE"

unzip(zipped_folder,exdir=unzipped_folder)
}

```

Create functions to import vegetation height files and stratify data by bioclimatic zone and region.

```{r}
# Function to read in multiple files resulting from GEE exports
readVegHeightFiles <- function(uniqueString){
  dir <- '/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights/'
  files <- list.files(dir)[str_detect(list.files(dir), uniqueString)]
  #print(files)
  
  dat <- tibble()
  for (i in files){
    dat <- dat %>% 
      bind_rows(read_csv(paste0(dir, i)) %>%
                  mutate(ssbid = substr(str_split(i, '_')[[1]][3], 1, 14)))
  }
  return (dat)
}

# Bioclimatic zone lookup
vegLookup <- tibble(
  vegClimZone = c(1,2,3,4,5), 
  vegClimZoneLab = c('Boreonemoral sone (BN)','Lavalpin sone (LA)','Mellomboreal sone (MB)','Nordboreal sone (NB)','Sørboreal sone (SB)')
  )

# Bioclimatic zone and region cleaning function
cleanRegClim <- function(data){
  
  dataOut <- data %>%
    mutate(region=ifelse(region_id == 1, 'Nord-Norge',
                         ifelse(region_id == 2, 'Midt-Norge',
                                ifelse(region_id == 3, 'Østlandet',
                                       ifelse(region_id == 4, 'Vestlandet', 'Sørlandet'))))) %>%

    mutate(vegClimZone = round(vegClimZone)) %>%
    left_join(vegLookup, by = 'vegClimZone') %>%
    dplyr::select(-region_id, -vegClimZone) %>%
    drop_na(vegClimZoneLab, region)
  
  return (dataOut)
  
}

# Create intersection of the two strata layers

bioclim <- st_transform(bioclim, st_crs(regions))
bioClimReg <- bioclim %>%
  st_intersection(regions) %>%
    mutate(vegClimZoneLab = NAVN) %>%
    dplyr::select(region, vegClimZoneLab) %>%
  rowid_to_column("ID")

bioClimReg$vegClimZoneLab <- factor(bioClimReg$vegClimZoneLab, levels=vegclimzonelvl)
bioClimReg$region <- factor(bioClimReg$region, levels=regionlvl)
```

#### 7.7.1 Area covers

Import the CSV files generated in GEE related to area covers.

```{r}

# Import data coverages per SSB 10km grid cell
areaCovers <- read_csv('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/area_cover_grid.csv') %>%
  dplyr::select(-'.geo', -'system:index')

# Calculate percentage cover relative to the land area in each cell
areaCoversPerc <- areaCovers %>%
  gather(key, val, vaatmark_pop, aapne_pop, semi_pop, vaatmark_nin, aapne_nin, semi_nin, lidarCover, skog) %>%
  mutate(type = ifelse(str_detect(key, 'pop'), 'pop', 
                       ifelse(str_detect(key, 'nin'), 'nin', 
                              ifelse(key == 'lidarCover', 'lidar', NA)))) %>%
  mutate(ecosystem = ifelse(str_detect(key, 'aapne'), 'Naturlig åpne', 
                       ifelse(str_detect(key, 'vaatmark'), 'Våtmark', 
                              ifelse(str_detect(key, 'semi'), 'Semi-naturlig',NA)))) %>%
  mutate(areaPerc = val/land*100,
         areaPerc = ifelse(is.na(areaPerc), 0, areaPerc)) %>%
  dplyr::select(SSBID, key, type,ecosystem, areaPerc)

```

```{r coverage-map-enc, fig.height=5, fig.width=15, fig.cap="Map of Norway showing coverage of different data sets."}

c1 <- ssb10km %>% 
  left_join(areaCoversPerc %>%
              filter(type == 'nin') %>%
              group_by(SSBID) %>%
              summarise(areaPerc = sum(areaPerc, na.rm=T)))  %>%
  ggplot() +
  geom_sf(aes(fill=areaPerc), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.3) +
  scale_fill_gradientn(colours = c('black', 'orange'),
                       name = '% cover',
                       limits=c(0, 2),
                       oob=scales::squish) +
  theme_void() +
  theme(legend.position = c(0.7, 0.4)) +
  ggtitle('A) NiN polygons with good condition')
#c1
c2 <- ssb10km %>% 
  left_join(areaCoversPerc %>%
              filter(type == 'pop') %>%
              group_by(SSBID) %>%
              summarise(areaPerc = sum(areaPerc, na.rm=T)))  %>%
  ggplot() +
  geom_sf(aes(fill=areaPerc), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.3) +
  scale_fill_gradientn(colours = c('black', 'orange'),
                       name = '% cover',
                       limits=c(0, 25),
                       oob=scales::squish) +
  theme_void() +
  theme(legend.position = c(0.7, 0.4)) +
  ggtitle('B) Population polygons')
#c2
c3 <- ssb10km %>% 
  left_join(areaCoversPerc %>%
              filter(type == 'lidar') %>%
              group_by(SSBID) %>%
              summarise(areaPerc = sum(areaPerc, na.rm=T)))  %>%
  ggplot() +
  geom_sf(aes(fill=areaPerc), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.3) +
  scale_fill_gradientn(colours = c('black', 'orange'),
                       name = '% cover',
                       limits=c(0, 100),
                       oob=scales::squish) +
  theme_void() +
  theme(legend.position = c(0.7, 0.4)) +
  ggtitle('C) LiDAR canopy height model')
#c3

coverageFig <- grid.arrange(c1, c2, c3, ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 

```

#### 7.7.2 Forest heights

Import forest heights per region-bioclimatic zone strata.

```{r}

skog_region_bioclim <- read_csv("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights_skog_climZoneRegion.csv")

names(skog_region_bioclim)[2:4] <- c("vegClimZone","skog","region_id")

skog_region_bioclim <- skog_region_bioclim %>%
  dplyr::select(-c('system:index','.geo'))

skog_region_bioclim <- cleanRegClim(skog_region_bioclim)

```

```{r coverage-map-forestheight, fig.height=5, fig.width=5, fig.cap="Map of Norway showing 90th percentile forest heights per region-bioclimatic strata."}

(ggskog <- bioClimReg %>% 
  left_join(skog_region_bioclim) %>% 
  ggplot() +
  geom_sf(aes(fill=skog), color=NA) +
  #geom_sf(data=bioClimReg, fill=NA, size=0.3) +
  scale_fill_gradientn(colours = c('black', '#93C572'),
                       name = '90th percentile forest height (m)',
                       #limits=c(0, 2),
                       oob=scales::squish) +
  theme_void() +
  theme(legend.position = c(0.8, 0.4))
 )


```

#### 7.7.3 Reference heights

Import the reference vegetation heights generated in GEE and define the upper limit of the ecological condition score per ecosystem type.

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
    
    # Import median LiDAR heights for NiN polygons (references)
    refecosysttypeRaw <- readVegHeightFiles(paste0(ecosysttype,'_ref')) %>%
    mutate(ref = chm) %>%
    dplyr::select(-'.geo', -'system:index', -chm)
    
    # Add region and bioclim zones and calculate the median per strata. This will form the upper limit of the ecological condition score (i.e. good condition)
  refecosysttype <- cleanRegClim(refecosysttypeRaw) %>%
    group_by(region, vegClimZoneLab) %>%
    summarise(ref = median(ref, na.rm=T)) %>%
    # Remove rows for Lavalpin sone (LA)
    filter(vegClimZoneLab != 'Lavalpin sone (LA)')
  
  
    # Export to file for reference
    refecosysttype %>% st_write(paste0('../data/ref',ecosysttype,'.csv'), append=FALSE)
    
    assign(paste0('ref',ecosysttype), refecosysttype)

}
```

```{r ref-wet-enc, fig.cap="Reference vegetation height in wetland ecosystems under the forest line in Norway."}

refvaatmark  <- read_csv('../data/refvaatmark.csv')

refvaatmark$region <- factor(refvaatmark$region, levels=regionlvl)
refvaatmark$vegClimZoneLab <- factor(refvaatmark$vegClimZoneLab, levels=vegclimzonelvl)

refvaatmark %>%
  ggplot(aes(x = region, y = ref))+
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  theme(axis.text.x = element_text(angle = -45, vjust = 0.5, hjust = 0.2, size = 12))+
  facet_wrap(.~vegClimZoneLab)+
  labs(y = "Reference vegetation height (m)",
       x = " ")
```

```{r ref-open-enc, fig.cap="Reference vegetation height in natural open ecosystems under the forest line in Norway."}

refaapne <- read_csv('../data/refaapne.csv')

refaapne$region <- factor(refaapne$region, levels=regionlvl)
refaapne$vegClimZoneLab <- factor(refaapne$vegClimZoneLab, levels=vegclimzonelvl)

refaapne %>%
  ggplot(aes(x = region, y = ref))+
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  theme(axis.text.x = element_text(angle = -45, vjust = 0.5, hjust = 0.2, size = 12))+
  facet_wrap(.~vegClimZoneLab)+
  labs(y = "Reference vegetation height (m)",
       x = "")
```

```{r ref-semi-enc, fig.cap="Reference vegetation height in semi-natural ecosystems under the forest line in Norway."}

refsemi <- read_csv('../data/refsemi.csv')

refsemi$region <- factor(refsemi$region, levels=regionlvl)
refsemi$vegClimZoneLab <- factor(refsemi$vegClimZoneLab, levels=vegclimzonelvl)

refsemi %>%
  ggplot(aes(x = region, y = ref))+
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  theme(axis.text.x = element_text(angle = -45, vjust = 0.5, hjust = 0.2, size = 12))+
  facet_wrap(.~vegClimZoneLab)+
  labs(y = "Reference vegetation height (m)",
       x = " ")
```

#### 7.7.4 Population heights

Import the population vegetation heights generated in GEE.

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
  
      ecosysttype <- ecosysttypes[i]

    # The wetland population dataset is exported differently from GEE than the two other population datasets.
  if(ecosysttype != "vaatmark"){
    
      # Import median LiDAR heights for GFA polygons for population measurement
    popecosysttypeHt <- readVegHeightFiles(paste0(ecosysttype,'_pop'))  %>%
      mutate(pop = chm)%>%
      dplyr::select(-chm)
    
    # Turn into spatial objects using the .geo column in the CSV
    popecosysttype <- st_as_sf(bind_cols(popecosysttypeHt,geojsonsf::geojson_sf(popecosysttypeHt$.geo)))
    
  } else {
    
   # Import median LiDAR heights for GFA polygons for population measurement
    vaatmark_pop <- read_csv("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights/vaatmark_pop.csv") %>%
      mutate(pop = chm,
             region_id = id,
             ssbid=as.character(ssbid))%>%
      dplyr::select(-id, -chm, -type, -strat)
    
    # Turn into spatial objects using the .geo column in the CSV
    vaatmark_points <- st_as_sf(bind_cols(vaatmark_pop,geojsonsf::geojson_sf(vaatmark_pop$.geo)))
    
    # Metric crs
    vaatmark_pointsm <- st_transform(vaatmark_points, st_crs(regions))
    
    # Function to create a 30x30 m polygon square around each point
    create_square <- function(point, size = 20) {
      st_buffer(point, dist = size / 2, endCapStyle = "SQUARE")
      }
    # Apply the function to each point
    vaatmark_poly <- st_geometry(vaatmark_pointsm) %>% 
      lapply(create_square) %>% 
      st_sfc() %>%
      st_set_crs(st_crs(vaatmark_pointsm))
    
    # Lat long crs
    vaatmark_poly <- st_transform(vaatmark_poly, st_crs(vaatmark_points))
 
    # Combine the squares with the original attributes
    popecosysttype <- st_sf(vaatmark_points, geometry = vaatmark_poly)


  }
      
  
  popecosysttype <- cleanRegClim(popecosysttype)
  
  assign(paste0('pop',ecosysttype), popecosysttype)

  
}
```

#### 7.7.5 Combine datasets for heights

Combine the reference (good condition) and forest heights (poor condition) datasets with the population heights dataset per ecosystem type per strata. The forest heights will define the lower limit of the ecological condition score (ie. poor condition) for vaatmark and semi-natural land. However, for naturlig åpen, which is here represented as GRUK, we will set a given threshold (median = 0.8 m) as a bad condition.

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
  
  ecosysttype <- ecosysttypes[i]
  
  popecosysttype <- get(paste0("pop",ecosysttype))

  if(ecosysttype != "aapne"){
    
     # Combine median LiDAR heights for forest per region and bioclimatic zone combination with population heights.This will form the lower limit of the ecological condition score (ie. poor condition)
  popskogecosysttype <- popecosysttype %>%
    left_join(skog_region_bioclim, by = c('vegClimZoneLab','region'))
  
    
  } else {
     # Add the threshold for poor ecological condition in GRUK
      aapne_region_bioclim <- skog_region_bioclim
      aapne_region_bioclim$skog <- 0.8
    
        popskogecosysttype <- popecosysttype %>%
    left_join(aapne_region_bioclim, by = c('vegClimZoneLab','region'))
        
  }
  
  refecosysttype <- read_csv(paste0('../data/ref',ecosysttype,'.csv'))

  
  # Combine the reference heights, forest heights and population heights into one dataset
  #set.seed(123)
  ecosysttypeHts <- popskogecosysttype %>%
    #sample_n(100000) %>%
    as_tibble() %>% 
    dplyr::select(-geometry) %>%
    left_join(refecosysttype, by=c('vegClimZoneLab', 'region')) %>%
    gather(type, height, ref, pop, skog) %>%
    group_by(`system:index`, region, vegClimZoneLab, type) %>%
    summarise(height = mean(height)) %>%
    pivot_wider(values_from = height, names_from = type) %>%
    
    # If population height is less than the reference value, then it is automatically "good" condition - ie. it inherits the reference height so that the rescaled value will be 1
    mutate(pop = ifelse(pop < ref, ref, pop)) %>%
    drop_na(pop, ref) #%>%
    #left_join(ecosysttypeSkogRegionalRef, by = c('vegClimZoneLab', 'region')) %>%
    #mutate(skog = ifelse(is.na(skog), skogFill, skog)) %>%
    #dplyr::select(-skogFill) %>%
    #filter(skog < 30)
  #colSums(is.na(ecosysttypeHts))
  
  ecosysttypeHts$region <- factor(ecosysttypeHts$region, levels=regionlvl)
  ecosysttypeHts$vegClimZoneLab <- factor(ecosysttypeHts$vegClimZoneLab, levels=vegclimzonelvl)

  assign(paste0(ecosysttype,"Hts"), ecosysttypeHts)
  
}

```

## 8. Spatial units

<!--# Describe the spatial units that you rely on in your analyses. Highlight the spatial units (the resolution) that the indicator values should be interpretted at. Potential spatial delineation data should eb introduced under 7.1. Datasets. We recomend using the SEEA EA terminology opf Basic Spatial Units (BSU), Ecosystem Asses (EA) and Ecosystem Accounting Area (EAA). -->

## 9. Analyses

<!--# Use this header for documenting the analyses. Put code in seperate code chunks, and annotate the code in between using normal text (i.e. between the chunks, and try to avoid too many hashed out comments inside the code chunks). Add subheaders as needed. -->

We will calculate the gjengroing index for each population polygon over Norway using a Sigmoid scaling function.

```{r}

# Define Sigmoid scaling function
scaleSigmoid <- function(variable){
  refLow <- min(variable)
  refHigh <- max(variable)
  thr <- (refHigh-refLow)/2
  indicator_LowHigh <- (variable - refLow)/(refHigh - refLow)
  indicator_LowHigh[indicator_LowHigh[] < 0] <- 0
  indicator_LowHigh[indicator_LowHigh[] > 1] <- 1
  indicator_sigmoid <- 100.68*(1-exp(-5*(indicator_LowHigh)^2.5))/100
  return (round(indicator_sigmoid, 4))
}

```

### 9.1 Scaled indicator values at polygon level

!! INSERT TEXT

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
    
    ecosysttypeHts <- get(paste0(ecosysttype,'Hts'))
    popecosysttype <- get(paste0('pop',ecosysttype))

    
  # Calcualte gjengroing index values
  ecosysttypeIndexPoly <- ecosysttypeHts  %>%
    # Gather into long format so that we can mutate the scaleSigmoid() function
    gather(type, height, ref, pop, skog) %>%
    group_by(`system:index`) %>%
    mutate(index = scaleSigmoid(height)) %>%
    # Because short vegetation is good condition, we must invert the scaled indicator
    mutate(index = 1-index) %>%
    # Get the indicator values for the population polygons only (ref and skog will be 1 and 0)
    filter(type == 'pop') %>%
    dplyr::select(-type, -height) %>%
    # Join with original data to get the actual median vegetation heights for each indicator score
    left_join(ecosysttypeHts %>% dplyr::select("system:index", pop, ref, skog)) %>%
    left_join(popecosysttype %>% dplyr::select("system:index", ssbid))
    
  # Make into spatial objects
  ecosysttypeIndexPolySpat <- popecosysttype %>%
    dplyr::select("system:index") %>%
    left_join(ecosysttypeIndexPoly) %>%
    filter(!is.na(index)) %>%
    # Transform to correct projection
    st_transform(st_crs(regions))

  assign(paste0(ecosysttype,"IndexPolySpat"), ecosysttypeIndexPolySpat)
    
}


```

Here we will visualize the spatial variation in scaled gjengroings indicator values, as well as the vegetation heights for reference (good condition), indicator, and mature forest (poor condition) over the country. We could plot all the polygons, but it is computationally intensive and very difficult to visualize spatial variations over the entire country. Therefore we will calculate the area-weighted mean in values for each bioclimatic-region strata over the country.

```{r}
  
ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    ecosysttype <- ecosysttypes[i]

      ecosysttypeIndexPolySpat <- get(paste0(ecosysttype, "IndexPolySpat"))
            
      # Get area-weighted mean for reference, forest and population vegetation heights for each unique bioclimatic zone-region combination
      ecosysttypeIndexStrata <- bioClimReg %>% 
        #sample_n(10000) %>%
        st_join(ecosysttypeIndexPolySpat %>% 
                    mutate(area = as.numeric(st_area(geometry))), st_intersects, largest=T) %>%
        group_by(ID) %>%
        summarise_at(vars(pop, ref, skog, index), funs(weighted.mean(., w=area, na.rm=TRUE)))%>% 
        as_tibble() %>% 
        dplyr::select(-geometry)
      
       # Write out for import later
      ecosysttypeIndexStrata %>% write_csv(paste0('../data/',ecosysttype,'IndexStrata.csv'))
      
      assign(paste0(ecosysttype, "IndexStrata"),ecosysttypeIndexStrata)
      
}

```

### 9.3 Scaled indicator values at 50km grid level

Using the polygon-level indicator scores, we will aggregate to 50km grid level to explore the spatial variation over Norway. We are doing this as an alternative way of visualizing the broad-scale patterns as presented in the section above where we used bioclimatic-elevation strata.

Here we will use a weighted average, but test out the eaTools::ea_spread function! It takes some time to run so best to do this overnight, or to parallelize in some way.

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]

      
    ecosysttypeIndexPolySpat <- get(paste0(ecosysttype,'IndexPolySpat'))

    # Aggregate polygon index scores to grid level using eaTools ea_spread function
    ecosysttypeIndexGrid <- eaTools::ea_spread(indicator_data = ecosysttypeIndexPolySpat,
                                            indicator = index,
                                            regions = ssb50km,
                                            groups = SSBID,
                                            threshold = 1) %>%
    mutate(index = w_mean, ssbid = ID) %>%
    dplyr::select(ssbid, index, sd)
  
    # Export
    ecosysttypeIndexGrid %>% st_write(paste0('../data/',ecosysttype,'_index_grid.shp'), append=F)
    
    assign(paste0(ecosysttype, "IndexGrid"),ecosysttypeIndexGrid)
     
}
```

### 9.4 Scaled indicator values at regional level

Now we will aggregate up to the regional level for final reporting. We will use the same method as in the section above, except here we will use a different method to calculate the uncertainty value around the indicator values. The ea_spread function in eaTools uses a bootstrapping method to calculate the standard error in indicator values when aggregating from the polygon to regional level. Because we have hundreds of thousands of polygons per region, the resulting standard errors are extremely small. Therefore we will use the standard deviation in reference values per region. The standard deviation, as a percentage of the average reference value is used to calculate the uncertainty in the scaled indicator value.

```{r}

ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
      ecosysttype <- ecosysttypes[i]
  
      # Get the mean population, reference and forest heights per region for interpreting index values
      # The standard deviation is used later to define uncertainty around the indicator score
      ecosysttypeIndexPolySpat <- get(paste0(ecosysttype, "IndexPolySpat"))
      
      ecosysttypeHeightsRegion <- regions %>%
        st_join(ecosysttypeIndexPolySpat) %>% 
        as_tibble() %>%
        drop_na(index) %>%
        # Some errors in column names on the way but region.x and region.y are the same 
        mutate(region=region.x) %>%
        dplyr::select(-region.x, -region.y) %>%
        group_by(region) %>%
        summarise(pop_mean = mean(pop),
                  skog_mean = mean(skog),
                  ref_mean = mean(ref),
                  sd_ref = sd(ref))
  
     # Aggregate polygon index scores to regional level using eaTools
      ecosysttypeIndexRegion <- eaTools::ea_spread(indicator_data = ecosysttypeIndexPolySpat,
                                              indicator = index,
                                              regions = regions,
                                              groups = region,
                                              threshold = 1) %>%
      mutate(index = w_mean, region = ID) %>%
      dplyr::select(region, index, sd) %>%
      left_join(ecosysttypeHeightsRegion)
    
      ecosysttypeIndexRegion %>% st_write(paste0('../data/',ecosysttype,'_index_region.shp'), append=F)
  
      assign(paste0(ecosysttype, "IndexRegion"),ecosysttypeIndexRegion)
  
}

```

### 9.5 Validation

Run test on an independent subset of data. !! Må her antagelig gjøre delen hvor indikatoren defineres på en subset av populasjonen og at en annen del brukes for å testes på. Tar litt for lang tid å gjøre det for alle dataene og det er også ikke heldig. Kjør en test for hver av typene (våtmark, åpne og semi) for å se hvor mye du må trekke ut for å få en stabil indikator

## 10. Results

<!--# Repeat the final results here. Typically this is a map or table of indicator values.-->

### 10.1 Scaled indicator values at polygon level

```{r multiple-maps-enc, fig.width=9,fig.height=8, fig.cap="Maps of scaled and unscaled indicator values, as well as reference values. For the unscaled variables the legend is truncated at 5 m to ensure the same colour gradient for all maps."}
  
# Import datasets
ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    ecosysttype <- ecosysttypes[i]

    ecosysttypeIndexStrata <- read_csv(paste0('../data/',ecosysttype,'IndexStrata.csv'))
    
    assign(paste0(ecosysttype, "IndexStrata"),ecosysttypeIndexStrata)    
}


# Make plots of indicator heights and scaled condition values for each strata polygon

theme_legend_1 <- theme(legend.key.size = unit(0.25, 'cm'), #change legend key size
                        legend.key.height = unit(0.25, 'cm'), #change legend key height
                        legend.key.width = unit(0.25, 'cm'), #change legend key width
                        legend.title = element_text(size=6), #change legend title font size
                        legend.text = element_text(size=6), #change legend text font size
                        legend.position = c(0.8, 0.4)) #change legend position

makeStrataHeightMap <- function(data, var, title, limits){
  p <- bioClimReg %>%
    left_join(data, by = c('ID'))  %>%
    mutate(response = .[[var]]) %>%
    ggplot() + 
    geom_sf(aes(fill = response), color=NA)+
      scale_fill_gradientn(colors=viridis::viridis(10),
                           limits = limits,
                           oob = scales::squish,
                           name = 'Veg ht (m)')+
      ggtitle(title) +
      theme_void() +
    theme(plot.title = element_text(size=9)) +
    theme_legend_1
    
  return (p)
}

makeStrataIndicatorMap <- function(data, title){
  p <- bioClimReg %>%
    left_join(data, by = c('ID'))  %>%
    ggplot() + 
    geom_sf(aes(fill = index), color=NA)+
      scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                           limits = c(0,1),
                           name = 'Index')+
      ggtitle(title) +
      theme_void()+
    theme(plot.title = element_text(size=9)) +
    theme_legend_1
    
  return (p)
}

v1 <- makeStrataIndicatorMap(vaatmarkIndexStrata, 'A) Våtmark scaled indicator')
v2 <- makeStrataHeightMap(vaatmarkIndexStrata, "ref", 'B) Våtmark reference height', c(0,5))
v3 <- makeStrataHeightMap(vaatmarkIndexStrata, "pop", 'C) Våtmark indicator height', c(0,5))

a1 <- makeStrataIndicatorMap(aapneIndexStrata,  'E) Naturlig åpne scaled indicator')
a2 <- makeStrataHeightMap(aapneIndexStrata, "ref", 'F) Naturlig åpne reference height', c(0,5))
a3 <- makeStrataHeightMap(aapneIndexStrata, "pop", 'G) Naturlig åpne indicator height', c(0,5))

s1 <- makeStrataIndicatorMap(semiIndexStrata,  'I) Semi-naturlig scaled indicator')
s2 <- makeStrataHeightMap(semiIndexStrata, "ref", 'J) Semi-naturlig reference height', c(0,5))
s3 <- makeStrataHeightMap(semiIndexStrata, "pop", 'K) Semi-naturlig indicator height', c(0,5))


strataHeightPlot <- grid.arrange(v1,v2,v3,
                                 a1,a2,a3, 
                                 s1,s2,s3, 
                                 ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 

```

### 10.2 Scaled indicator values at 50km grid level

```{r grid-level-enc, fig.cap="Maps displaying scaled encroachment indicator values on a 50 km grid level"}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
  
    ecosysttypeIndexGrid <- st_read(paste0('../data/',ecosysttype,'_index_grid.shp')) 
  
    assign(paste0(ecosysttype, "IndexGrid"),ecosysttypeIndexGrid)
     
}

vGrid1 <- vaatmarkIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('A) Våtmark gjengroing condition')

vGrid2 <- aapneIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('B) Naturlig åpne condition')

vGrid3 <- semiIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('C) Semi-naturlig condition')



indexGridFig <- grid.arrange(vGrid1, vGrid2, vGrid3, ncol=3, widths=c(1,1,1),
                             padding = unit(0, "line"), newpage = T) 

```

### 10.3 Scaled indicator values at regional level

Present the indicator values as table, plots, and maps:

```{r regional-level-enc, fig.cap="Maps displaying scaled encroachment indicator values on a regional level"}

ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
      ecosysttype <- ecosysttypes[i]
  
      ecosysttypeIndexRegion <- st_read(paste0('../data/',ecosysttype,'_index_region.shp'))
  
      assign(paste0(ecosysttype, "IndexRegion"),ecosysttypeIndexRegion)
}

# Join into a table to present values
vaatmarkTable <- vaatmarkIndexRegion %>% as_tibble() 
aapneTable <- aapneIndexRegion %>% as_tibble() 
semiTable <- semiIndexRegion %>% as_tibble() 

# Join ecosystem types and calculate uncertainty
indicatorTable <- vaatmarkTable %>% mutate(Ecosystem = 'Våtmark') %>%
  bind_rows(aapneTable %>% mutate(Ecosystem = 'Naturlig åpne')) %>%
  bind_rows(semiTable %>% mutate(Ecosystem = 'Semi-naturlig')) %>%
  # Calculate the error based on the standard deviation in reference polygon heights
  # as a percentage of the reference height, and multiply by index score
  mutate(sd = (sd_ref/ref_mean)*index)

# Format the table for presentation
indicatorTable_formatted <- regions %>%
  left_join(indicatorTable) %>% as_tibble() %>%
  dplyr::select(-geometry)  %>%
  dplyr::select( region, Ecosystem, index, sd, pop_mean, ref_mean, skog_mean) %>%
  mutate_if(is.numeric, round, 2)
names(indicatorTable_formatted) <- c( "Region", "Ecosystem",
                                      "Scaled indicator",  "Scaled Std.dev",
                                      "Indicator height","Reference height",
                                      "Mature forest height")

# Use knitr to visualize
knitr::kable(indicatorTable_formatted)

# Make plots of regional index values
getIndicatorPlot <- function(label){
  regions %>%
    left_join(indicatorTable %>%
                filter(Ecosystem == label)) %>%
    mutate(lowError = index-sd, 
           upError = index+sd,
           upError = ifelse(upError > 1, 1, upError)) %>%
    ggplot(aes(y=region, x=index)) +
    geom_point() +
    geom_segment(aes(yend=region, x=lowError, xend=upError)) +
    coord_cartesian(xlim=c(0,1)) +
    geom_vline(xintercept = 1) +
    geom_vline(xintercept = 0) +
    labs(x = 'Tilstandsverdi') +
    theme(legend.position = c(0.7, 0.4),
          axis.title.y=element_blank()) +
    ggtitle(label) 
}

i1 <- getIndicatorPlot('Våtmark')
i2 <- getIndicatorPlot('Naturlig åpne')
i3 <- getIndicatorPlot('Semi-naturlig')

indicatorGraphFig <- grid.arrange(i1, i2, i3, ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 

# Make maps of regional index values
getIndicatorMap <- function(data, label){
  regions %>%
    left_join(data) %>%
    ggplot() +
    geom_sf(aes(fill=index)) +
    scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                         limits = c(0,1))+
    ggtitle(label)+
    theme_void()+
    theme(legend.position = c(0.7, 0.4))
}

m1 <- getIndicatorMap(vaatmarkTable, 'A) Våtmark')
m2 <- getIndicatorMap(aapneTable, 'B) Naturlig åpne')
m3 <- getIndicatorMap(semiTable, 'C) Semi-naturlig')

indicatorGMapFig <- grid.arrange(m1, m2, m3, ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 
```

"From these tables, figures and maps we can see that the gjengroing condition indicator scores are on average above 0.8 and therefore indicate a good overall condition in Norway. Østlandet comes out best for våtmark and semi-naturlig åpne ecosystems. Nord-Norge has poorest condition for semi-naturlig åpne ecosystems, while vestlandet has the poorest scores for våtmark."

### 10.4 Validation

## 12. Export file

<!--# Display the code (don't execute it) or the workflow for exporting the indicator values to file. Ideally the indicator values are exported as a georeferenced shape or raster file with indicators values, reference values and errors. You can also chose to export the raw (un-normalised or unscaled variable) as a seperate product. You should not save large sptaial output data on GitHub. You can use eval=FALSE to avoid code from being executed (example below - delete if not relevant) -->

We will export gjengroing indicator values at three levels: - polygon level - 50km grid level - regional level

```{r export}
#| eval: false

ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
    ecosysttype <- ecosysttypes[i]
      
    # Polygon level
    ecosysttypeIndexPolySpat <- get(paste0(ecosysttype,"IndexPolySpat"))
    ecosysttypeIndexPolySpat  %>%
    #mutate(area = as.numeric(st_area(geometry)))%>% 
    #filter(area > 7500) %>%
    mutate(id = `system:index`,
           region = region, 
           vegZn = vegClimZoneLab) %>%
    dplyr::select(-"system:index", -vegClimZoneLab, -elevation) %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index.shp"), append=FALSE)
      
    # Grid level
    ecosysttypeIndexGrid <- get(paste0(ecosysttype,"IndexGrid"))
    ecosysttypeIndexGrid %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index_grid.shp"), append=FALSE)
      
    # Region level
    ecosysttypeIndexRegion <- get(paste0(ecosysttype,"IndexRegion"))
    ecosysttypeIndexRegion %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index_region.shp"), append=FALSE)
      

}
```
