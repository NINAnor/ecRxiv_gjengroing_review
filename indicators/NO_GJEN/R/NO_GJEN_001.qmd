---
title: "Woody enchroachment - approach based on LiDAR"
format: 
  html:
    embed-resources: true
    code-fold: true
execute: 
  cache: true
author:
  - name: Ida M. Mienna
    email: ida.mienna@nina.no
    affiliations:
      - id: myID
        name: The Norwegian Institute for Nature Research (NINA) 
  - name: Zander Venter 
    affiliations:
      - ref: myID    
date: September 30, 2024 
callout-icon: false
bibliography: references.bib
---

```{r setup}
#| include: false
library(knitr)
library(sf)
library(tidyverse)
library(gridExtra)
library(kableExtra)
library(RColorBrewer)
library(flextable)
library(here)

# Set global variable defining whether you want to run everything from scratch (very long runtime) or use pre-exported data (short runtime)
runFromScratch <- FALSE

knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)


```

```{r source}
#| echo: false
source(here::here("R/_common.R"))
```

```{r}
#| echo: false
meta <- readxl::read_xlsx("../metadata.xlsx")
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
name <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

::: {layout-ncol="3"}
```{r}
#| echo: false
#| results: asis
status(st)
```

::: {.callout-note style="background: cornsilk;"}
## Recomended citation

`r paste(auth, year, name, "v.", version, "ecRxiv", url, sep=" ")`
:::

::: {.callout-note style="background: khaki;"}
## Version

`r version`
:::
:::

```{=html}
<details>
<summary>Show metadata</summary>
```
```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kbl(col.names = NULL) 

```

</details>

# Gjengroing / Woody enchroachment

<br />

<br />

::: callout-warning
## In review

This indicator is in review and is subject to change
:::

<br />

<hr />

## 1. Introduction

The Norwegian word "gjengroing" is directly translated to "regrowing" in English. The gjengroing indicator describes the regrowth of woody vegetation (trees and bushes) in open ecosystems (open wetlands, naturally open and open semi-natural meadows) across Norway. We will use a spatial reference approach where reference areas define good or optimal vegetation regrowth heights.

The workflow spans two platforms including RStudio and Google Earth Engine (GEE). To reproduce this workflow you will need a GEE account and access to the NINA RStudio and R/GeoSpatialData servers.

## 2. About the underlying data

We rely on the following datasets:

-   [NiN nature type polygons](https://kartkatalog.miljodirektoratet.no/Dataset/Details/2031) are used to identify reference areas with good ecological condition.
-   [Nasjonalt grunnkart](https://nibio.brage.unit.no/nibio-xmlui/handle/11250/3120510) is used as the population sample for wetland. The population sample are the areas used to determine ecological condition relative to the reference areas. We also use the grunnkart-data to identify forest for defining the lower limit of ecological condition index (i.e. poor condition).
-   GRUK dataset is used as population sample for natural open areas. The dataset is based on a method for area-representative monitoring of dry calcareous grassland (åpent grunnlendt kalkmark). <!--# Ref? -->
-   [ASO dataset](https://www.miljodirektoratet.no/ansvarsomrader/overvaking-arealplanlegging/miljoovervaking/overvakingsprogrammer/natur-pa-land/semi-naturlig-eng/) is used as population sample for semi-natural areas. This dataset is based on a method for area-representative monitoring of semi-natural grasslands.
-   LiDAR-derived digital elevation model from Kartverket's [høydedata](https://hoydedata.no/LaserInnsyn/). This includes both a terrain (DTM) and surface model (DSM). We calculate the canopy height model (CHM=DSM-DTM) to get the height of objects above the ground. From this we remove buildings, and what remains is vegetation - mostly trees but also some bushes or smaller woody plants.
-   [FKB building footprints](https://kartkatalog.geonorge.no/metadata/fkb-bygning/8b4304ea-4fb0-479c-a24d-fa225e2c6e97) are used to isolate vegetation in the LiDAR height data.
-   A [European satellite-based map](https://www.nature.com/articles/s41893-020-00609-y) of forest clear cuts is used for identifying grunnkart forest patches in near-climax successional stages [@senf2021mapping].
-   The regional delineation for Norway (five regions; Nord-Norge, Midt-Norge, Vestlandet, Østlandet, Sørlandet) are used for stratifying reference (good condition) and forest (poor condition) heights (together with bioclimatic zones) and aggregating and reporting gjengroing condition values.
-   [Bioclimatic zones](https://artsdatabanken.no/Pages/181901/Bioklimatiske_soner). We use this dataset (together with the regions) to stratify reference and forest heights by bioclimatic (also referred to as vegetation/climatic) zones.
-   The [SSB 10km and 50km grids](https://kartkatalog.geonorge.no/metadata/statistiske-rutenett/558c4995-9c55-4686-8143-f329f87ce33f) is used for visualization purposes.

For each of the three main ecosystem types, we have defined a population sample consisting of spatially delineated areas that are either area representative within a given context (GRUK), or which have complete coverage over Norway. For Naturally open areas the population sample are GRUK polygons. These localities are a representative sample of sparesly vegetated calcareous areas close to the coast around the Oslo fjord area. The scope of this indicator does in other words is only a very narrow subsectiono f the definition of the main ecosystem type, and there is data only from two out of five regions in Norway. For semi-natural meadows we define the population sample as polygons from the ASO monitoring program. These are 500-700 meadows across Norway, samples systematically to achieve a balanced sample. For wetlands, we use types in nasjonalt grunnkart defined as *Klasse 7 Våtmark*.

### 2.1 Spatial and temporal resolution

The indicator will cover the mainland of Norway. The analysis will be stratified by (1) våtmark (wetland), (2) åpen (natural open), and (3) semi-naturlig (semi-natural) ecosystems below the forestline. The LiDAR data cover a range of years and therefore the indicator represents conditions for circa 2010 to 2021.

Temporal coverage: Circa 2010 to 2023. This is a single snapshot and not a change analysis. In the future, when LiDAR data has been repeated across the country, it may be possible to do a change assessment.

### 2.2 Original units

The original units for the canopy model is meters. This is the height of the vegetation within reference, polygon and forest areas.

### 2.3 Additional comments about the dataset

There is no plan yet to update the LiDAR dataset over the whole of Norway. Therefore there is a related enchorchemnt indicator being developed that uses satellite or aerial images that are updated more frequently.

## 3. Indicator properties

### 3.1. ECT

ECT: Structural state characteristic (B2)

### 3.2. Ecosystem condition characteristic

In good condition, the three target ecosystems are characterised as being open, with little trees.

### 3.3. Other standards

The indicator is related to the *Funksjonell sammensetning innen trofiske nivåer* in the Norwegian standard fro ecosystem condition assessments.

### 3.4. Collinearities with other indicators

There is possibly a collinearity with a [preliminary indicator](https://ninanor.github.io/ecosystemCondition/NDVI-indicator-natopen.html) called based on the normalized difference vegetation index (NDVI) as a proxy for vegetation production. NDVI can be correlated with vegetation height and consequently yield similar results to the LiDAR-based gjengroing indicator.

For wetlands especially, woody enchroachment is associated with trenching, which is the topic of an indicator based on [field-recorded mire trenching](https://ecoevorxiv.org/repository/view/7221/), and another indicator based on the [amount of trenching](https://ninanor.github.io/mire-trenching/) as inferred from LiDAR.

## 4. Reference condition and values

### 4. 1. Reference condition

The reference condition is defined as a minimally disturbed state, with a climate similar to the 1961-1990 period, and with a native species assemblage similar as today. See @nybo_fagsystem_2017. This reference condition translates to onewhere open ecosystems are indeed open, with little to no woody encroachment. For natural ecosystems this reflects a state where climate warming, wetland drainage, and alien species etc have not led to any net loss of these nature types and their internal functioning. For semi natural ecosystems it reflects a state where traditional husbandry is keeping the ecosystems open due to grazing and hay making.

### 4. 2. Reference values

#### 4.2.1 Minimum and maximum values

The methodology used to calculate the *gjengroing* indicator is outlined in @fig-enc-workflow. The workflow in the schematic is conducted for all reference and population polygons in Norway and repeated for each ecosystem type (våtmark, naturlig åpne og semi-naturlig), respectively. The indicator values are aggregated to a 50km grid (for visualisation purposes) and regional level (the ecosystem assests) at the end. The individual steps are discussed in turn in the following subsections.

```{r fig-enc-workflow}
#| fig.cap: |
#|   "Schematic illustration of how the encroachment indicator is calculated. 
#|   The lower bound for poor condition is set by LiDAR heights from mature forest 
#|   surrounding the population polygon. The upper bound for good condition is set 
#|   by regional median LiDAR heights within NiN polygons in the same 
#|   bioclimatic-elevation zone as the population polygon."
#| echo: false
#| out-width: '70%'
knitr::include_graphics("../img/gjengroing_schematic.jpg")
```

[NiN polygons](https://kartkatalog.miljodirektoratet.no/Dataset/Details/2031) of "Våtmark", "Naturlig åpne områder under skoggrensa" and "Semi-naturlig mark" with good ecological condition (we use the aggregated "Tilstand" variable assigned to each NiN polygon) are used as spatial references to define the optimal reference level (X~100~).

::: callout-warning
This part is subject to change. One reviewer suggested using the field-recorded variable *rask suksesjon* instead. This variable is essentially the same as woody enchroachemnt.
:::

The 50th percentile of LiDAR-derived vegetation heights within these polygons is used as X~100~. We cannot define local reference values based on proximity, because the NiN polygons are spatially biased and not close to all population polygons. Therefore we calculate regional reference values using regions and bioclimatic zones as stratification layers. These strata exuates to homogeneous ecosystem areas sensu @vallecillo_eu-wide_2022. We calculate the mean reference value for each unique combination of region-bioclimatic zone. When calculating the indicator for each population polygon, the X~100~ reference level is inherited from the region-bioclimatic zone it falls within.

Once we have the reference vegetation height for a given ecosystem type and region-bioclimatic zone, we need to define the minimum (or worst/bad) condition (X~0~). We use the 90th percentile of LiDAR-derived vegetation heights within "nasjonalt grunnkart skog" polygons to define a climax vegetation successional stage where gjengroing is at its most extreme, representing a completely deteriorated state for naturally open areas. In order not to include forest patches that have recently been harvested, we mask out any forest which has been clear-cut since 1986 [@senf2021mapping]. Here, 1986 is a hard limit defined by the clear-cut dataset which was based on Landsat imagery. Therefore we can be assured that we are measuring forest that is at least 35 years old. For the naturally open areas, however, we set a manual, expert derived threshold (0.8 m) for the X~0~ value (explained below).

The vegetation height percentiles are then scaled to between 0 and 1 using a sigmoid transformation @oliver2021new. See also @sec-scaling.

#### 4.2.2. Threshold value for defining *good ecological condition (if relevant)*

There are currently no other reference levels than X~0~ and X~100~ defined.

#### 4.2.3. Spatial resolution and validity

The reference levels are unique to homogeneous ecosystem areas defined as cross sections of region (five regions in Norway) and biomclimatic zone. Note that som biomclimatic zones may have been merged.

Indicators are normalised at the polygon level with reference levels that are defined for much bigger regions. This means that indicator values are not precise at the polygon level, and probably should not be presented at that scale. Indicator values aggregated to larger grid cells, such as a 50km grid, is ok (@sec-grid).

## 5. Uncertainties

<!--# Describe the main uncertainties or sources of error in the indicator or the underlying data. -->

The calculation of the indicator involves many small decisions which can have significant effects on the resulting conditions scores. **Therefore in the future it would be good to perform sensitivity analyses with each decision to test the effect on the outcome.** The decisions which would benefit from further exploration include:

-   **Selection of the reference and population areas.** Here we were limited to using NiN and GFA because these are arguably the best datasets currently available for this exercise. However, both NiN and GFA are spatially and thematically biased in some ways. Therefore, it may be worth exploring alternative datasets in the future.

-   **Definition of good condition states in NiN data.** Here we used the overall "tilstand" score for each NiN reference polygon. However, the overall score is a combination of several sub-scores that may or may not be relevant for ecological condition. For instance, ditches or wheel marks in wetlands is a common condition score in NiN, however it is debatable as to whether this should be considered a part of ecological condition. Therefore it may be beneficial to attempt repeating the indicator calculation using sub-categories of "tilstand" in the NiN data.

    -   **This will only make sense for semi-naturlig and naturlig åpen as gjengroing is one of the "tilstand"-indicators.**

::: callout-warning
The point below is subject to change. One review suggested quantifying uncertainty using the estimated polygon level indicator values instead.
:::

-   **Quantification of uncertainty around indicator scores.** Here we used the standard deviation in the vegetation heights for reference (NiN) polygons within each region to quantify the uncertainty around scaled indicator scores. We did this because the method used in `eaTools::ea_spread()` function is a bootstrapping approach which resulted in extremely small uncertainty estimates due to the large number of polygons included in our analysis. [In the future, a better method for quantifying uncertainty is needed.](https://github.com/NINAnor/eaTools/issues/17) Perhaps by running sensitivity analyses that test several variations of the points mentioned above can form the basis for quantifying an error margin around indicator values.

## 6. References

<!--# You can add references manually or use a citation manager and add intext citations as with crossreferencing and hyperlinks. See https://quarto.org/docs/authoring/footnotes-and-citations.html -->

::: {#refs}
:::

Links to data and resources are also provided with hyperlinks in-line.

## 7. Datasets

<!--# Describe the unique datasets seperately under seperate headers (Dataset A, Dataset B, etc.-->

There are several datasets which are used in GEE which will not be imported into the R session here. These datasets have been obtained from the source and ingested into GEE by Zander Venter or Vegar Bakkestuen with the help of Miljødata section at NINA. They include

-   [Nasjonalt grunnkart](https://nibio.brage.unit.no/nibio-xmlui/handle/11250/3120510)
-   [LiDAR-derived digital elevation model from høydedata](https://hoydedata.no/LaserInnsyn/).
-   [FKB building footprints](https://kartkatalog.geonorge.no/metadata/fkb-bygning/8b4304ea-4fb0-479c-a24d-fa225e2c6e97)
-   [European forest clear-cut map](https://www.nature.com/articles/s41893-020-00609-y)
-   Population polygons for naturlig åpen areas (GRUK).

The remaining datasets will be imported into the R session.

### 7.1 Regions

The regional delineation for Norway (five regions) are used for aggregating and reporting gjengroing condition values.

```{r readRegions}
regions <- sf::st_read("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Regions/regions.shp",
                       quiet = T)

# Some issues with the letter "ø"
regions$region[regions$id == 3] <- "Østlandet"
regions$region[regions$id == 5] <- "Sørlandet"

regionlvl <- c("Nord-Norge", "Midt-Norge", "Vestlandet", "Østlandet", "Sørlandet")

regions$region <- factor(regions$region, levels=regionlvl)
```

### 7.2 Bioclimatic regions

The [Moen's bioclimatic regions](https://data.artsdatabanken.no//Natur_i_Norge/Natursystem/Beskrivelsessystem/Regional_naturvariasjon/Bioklimatisk_sone) are imported from NINA R/GeoSpatialData/-server.

```{r readBioclimatic}

vegclimzonelvl <- c("Lavalpin sone (LA)", "Nordboreal sone (NB)", "Mellomboreal sone (MB)", "Sørboreal sone (SB)", "Boreonemoral sone (BN)")


if(runFromScratch){
  bioclim <- st_read('/data/R/GeoSpatialData/BiogeographicalRegions/Norway_PCA_klima/Converted/Soner2017.shp',
                     quiet= T)
  bioclim <- st_transform(bioclim, "EPSG:4326")
  
  # The file is in tiles. Will therefore dissolve these by Sone_navn
  bioclim <- bioclim %>%
    group_by(Sone_navn) %>%
    summarise(geometry = st_union(geometry))
  
  # Add unique code for each name called KLASSE
  bioclim <- bioclim %>%
    mutate(KLASSE=as.numeric(as.factor(Sone_navn))) %>%
    rename(NAVN="Sone_navn")
  
  bioclim$NAVN <- factor(bioclim$NAVN, levels=vegclimzonelvl)
  
  # Export the file
    st_write(bioclim, '/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Bioclimatic_zones/bioclimzone.shp', append=FALSE)
    
  # To avoid few reference polygons per region-bioclimatic zone strata, we will merge together zones within specific regions. This merge is a qualitative decision based upon early analyses of number of reference polygons.
    bioclimreg <- bioclim %>%
      st_transform(st_crs(regions)) %>%
  st_intersection(regions) %>%
    mutate(vegClimZoneLab = NAVN) %>%
    dplyr::select(region, vegClimZoneLab) %>%
  rowid_to_column("ID")
    

    } else {
  
  bioclim <- st_read('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Bioclimatic_zones/bioclimzone.shp',
                     quiet = T)

}

```

### 7.3 SSB 10 and 50km grids {#sec-grid}

The [SSB 10km and 50km grids](https://kartkatalog.geonorge.no/metadata/statistiske-rutenett/558c4995-9c55-4686-8143-f329f87ce33f) are used for visualizing the distribution of available data and for aggregating gjengroing indicator scores.

```{r readGRid}
ssb10km <- st_read("/data/R/GeoSpatialData/Population_demography/Norway_SSB/Original/ssb_10km/ssb10km.shp",
  quiet = T
) %>%
  # mutate the id value so that it aligns with the data coming from GEE
  mutate(SSBID = as.numeric(SSBID) / 1000)
# Transform to the correct projection
ssb10km <- st_transform(ssb10km, st_crs(regions))

ssb50km <- st_read("/data/R/GeoSpatialData/Population_demography/Norway_SSB/Original/ssb_50km/ssb50km.shp",
  quiet = T
) %>%
  # mutate the id value so that it aligns with the data coming from GEE
  mutate(SSBID = as.numeric(SSBID) / 1000)
# Transform to the correct projection
ssb50km <- st_transform(ssb50km, st_crs(regions))
```

### 7.4 ASO

The [ASO dataset](https://www.miljodirektoratet.no/ansvarsomrader/overvaking-arealplanlegging/miljoovervaking/overvakingsprogrammer/natur-pa-land/semi-naturlig-eng/) is used as population polygons for semi-natural areas. The dataset consists both of open nature types (e.g. slåttemark) and non-open nature types (e.g. hagemark). The types that are non-open will thus be excluded from the dataset before exporting to Google Earth Engine.

```{r readASO}
if(runFromScratch){
st_read("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/ASO/ASO_naturområder_21-23.shp",
        quiet = T) %>%
    filter(naturtype %in% c("Slåttemark", "Naturbeitemark", "Semi-naturlig eng", "Eng-aktig sterkt endret fastmark", "Fuglefjell-eng og fugletopp", "Semi-naturlig våteng")) %>%
st_write("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/ASO/ASO_open.shp", append=F)
}
```

### 7.5 Reference areas: NiN polygons

NiN polygons are imported here from the NINA servers but are originally imported as a [dataset from Miljødirektoratet](https://kartkatalog.miljodirektoratet.no/dataset/Details/2031). The dataset is here filtered so that it only contains natural open areas of wetland, semi-natural land and other natural open areas under the forest line that do not fit into these two categories (e.g. åpent grunnlendt mark).

```{r prepareNiN}
if (runFromScratch) {
  # Function to extra hovedtype
  extract_hovedtype <- function(text) {
    matches <- str_match_all(text, "NA_(.*?)-")
    unique(matches[[1]][, 2])
  }

  nin <- st_read("/data/R/GeoSpatialData/Habitats_biotopes/Norway_Miljodirektoratet_Naturtyper_nin/Original/Naturtyper - Miljødirektoratets instruks/Naturtyper_nin_0000_norge_25833_FILEGDB.gdb",
    layer = "naturtyper_nin_omr",
    quiet = T
  ) %>%
    # Fix any invalid geometries
    mutate(validGeo = st_is_valid(SHAPE)) %>%
    filter(validGeo) %>%
    # Simplify ecosystem names
    mutate(hovedøkosystem = recode(hovedøkosystem,
      "våtmark" = "Vaatmark",
      "skog" = "Skog",
      "fjell" = "Fjell",
      "semi-naturligMark" = "Semi-naturlig",
      "naturligÅpneOmråderILavlandet" = "Naturlig aapne",
      "naturligÅpneOmråderUnderSkoggrensa" = "Naturlig aapne"
    ))


  # We need to filter out the ecosystems we are not interested in. First, we only include types that are non-alpine by removing the areas that overlap with the bioclimatic zone 'Lavalpin sone (LA)'.
  # nin <- st_difference(nin, bioclim[bioclim$NAVN == "Lavalpin sone (LA)",])

  # Not all alpine types do overlap with this bioclimatic zone due to the resolution of the bioclimatic zone dataset. Thus, we further need to remove these types. In addition, we remove forested wetland types and semi-natural types.
  nin <- nin %>%
    filter(!(hovedøkosystem %in% c("Skog", "Fjell"))) %>% # Remove forest and alpine ecosystem types
    # filter(!(naturtype %in% c('Åpen myrflate i lavalpin sone'))) %>% # Alpine
    # Remove nature types that can have a good condition but can also have a tree cover >10%
    filter(!(naturtype %in% c(
      # Trees (oaks) or are tree covered
      "Hule eiker",
      "Hagemark",
      "Lauveng",
      "Saltpåvirket strand- og sumpskogsmark",
      "Flommyr, myrkant og myrskogsmark",
      "Grankildeskog",
      "Sørlig kaldkilde",
      "Kaldkilde under skoggrensa",
      # Swamp forests
      "Svak kilde og kildeskogsmark",
      "Varmekjær kildelauvskog",
      "Gammel fattig sumpskog",
      "Rik gransumpskog",
      "Rik svartorsumpskog",
      "Kilde-edellauvskog",
      "Rik gråorsumpskog",
      "Kalkrik myr- og sumpskogsmark",
      "Rik vierstrandskog",
      "Rik svartorstrandskog",
      "Saltpåvirket svartorstrandskog",
      "Leirravine",
      "Kalkrik helofyttsump",
      # These types are often very sloped which will affect the reference value
      "Grotte",
      "Silt og leirskred",
      "Fossepåvirket berg"
    ))) %>%
    # T1 naturetypes (nakent berg) will often occupy sloped areas in forests and will thus have trees on them. To avoid that these areas affect the reference values, we will remove all types that are T1
    filter(!grepl("T1-", ninKartleggingsenheter)) %>%
    # Get the main ecosystem codes. As there are multiple types in a column, we need to use a function (see above)
    mutate(
      hovedtype = sapply(ninKartleggingsenheter, function(x) paste(extract_hovedtype(x), collapse = ",")),
      id = identifikasjon_lokalId
    ) %>%
    # Drop polygons with no condition score
    drop_na(tilstand)
  
# Export list of included nature types
nin |>
  as_tibble() |>
  group_by(hovedøkosystem) |>
  distinct(naturtype) |>
  arrange(hovedøkosystem) |>
  write_csv("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/NiN/includedNatureTypes.csv")


  # Export the data
  nin %>%
    # Only included specific columns
    #dplyr::select(id, hovedøkosystem, hovedtype, naturtypeKode, tilstand)
    dplyr::select(id, hovedøkosystem, tilstand) %>%
    st_transform("EPSG:4326") %>%
    st_write("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/NiN/nin_cleaned.shp", append = FALSE)
}
```

```{r tbl-printTable}
#| tbl-cap: "List of included nature types in the dataset for reference areas."
#| message: false

read_csv("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/NiN/includedNatureTypes.csv") |>
  kbl()
```

### 7.6 Import data to Google Earth Engine, run GEE JavaScript code and download data

-   **Import cleaned datasets (ASO and NiN data) to Google Earth Engine.**
-   **Run the following GEE JavaScript code by clicking on the hyperlink:** [GEE script](https://code.earthengine.google.com/08cdcffc0e9b8c1a89d240e0e207dceb). When you run the script, then click the Tasks tab in the GEE code editor and run the export tasks. The export files will appear in your Google Drive.
-   **Download the files from your Google Drive to the /data/gjengroing/From_GEE directory:**
    -   'area_cover_grid.csv' - this gives the area coverage of reference data, population data and LiDAR data for each 10x10km SSB grid cell.
    -   'vegHeights_skog_climZoneRegion.csv' - this gives the 90th height percentile for each region-bioclimatic strata.
    -   'vegHeights.zip' - this is a folder with hundreds of CSV files. These files contain the vegetation heights for reference and population over Norway. The exports were split by 50km grid to prevent hitting user memory limits in GEE.

### 7.7 Import Google Earth Engine data

Once you have run the GEE script above, and downloaded the data to the `/From_GEE/` directory, you can proceed with this R workflow.

If not already done manually, extract files from the zipped GEE folder.

```{r unzip}

if(runFromScratch){
    zipped_folder <- list.files("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE",
                            pattern=".zip$",full.names=T)
  unzipped_folder <- "/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE"

  for(i in 1:length(zipped_folder)){
  unzip(zipped_folder[i],exdir=unzipped_folder)
  
  }
}

```

Create functions to import vegetation height files and stratify data by bioclimatic zone and region.

```{r importHeightFiles}
#| warning: false
# Function to read in multiple files resulting from GEE exports
readVegHeightFiles <- function(dir, uniqueString){
  files <- list.files(dir)[str_detect(list.files(dir), uniqueString)]
  #print(files)
  
  dat <- tibble()
  for (i in files){
    dat <- dat %>% 
      bind_rows(read_csv(paste0(dir, i)) %>%
                  mutate(ssbid = substr(str_split(i, '_')[[1]][3], 1, 14)))
  }
  return (dat)
}

# Bioclimatic zone lookup
vegLookup <- tibble(
  vegClimZone = c(1,2,3,4,5), 
  vegClimZoneLab = c('Boreonemoral sone (BN)','Lavalpin sone (LA)','Mellomboreal sone (MB)','Nordboreal sone (NB)','Sørboreal sone (SB)')
  )

# Bioclimatic zone and region cleaning function
cleanRegClim <- function(data){
  
  dataOut <- data %>%
    mutate(region=ifelse(region_id == 1, 'Nord-Norge',
                         ifelse(region_id == 2, 'Midt-Norge',
                                ifelse(region_id == 3, 'Østlandet',
                                       ifelse(region_id == 4, 'Vestlandet', 'Sørlandet'))))) %>%

    mutate(vegClimZone = round(vegClimZone)) %>%
    left_join(vegLookup, by = 'vegClimZone') %>%
    dplyr::select(-region_id, -vegClimZone) %>%
    drop_na(vegClimZoneLab, region)
  
  return (dataOut)
  
}

# Create intersection of the two strata layers

bioclim <- st_transform(bioclim, st_crs(regions))
bioClimReg <- bioclim %>%
  st_intersection(regions) %>%
    mutate(vegClimZoneLab = NAVN) %>%
    dplyr::select(region, vegClimZoneLab) %>%
  rowid_to_column("ID")

bioClimReg$vegClimZoneLab <- factor(bioClimReg$vegClimZoneLab, levels=vegclimzonelvl)
bioClimReg$region <- factor(bioClimReg$region, levels=regionlvl)
```

#### 7.7.1 Area covers

Import the CSV files generated in GEE related to area covers.

```{r importCSVs}
#| message: false
# Import data coverages per SSB 10km grid cell
areaCovers <- read_csv("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/area_cover_grid.csv") %>%
  dplyr::select(-".geo", -"system:index")

# Calculate percentage cover relative to the land area in each cell
areaCoversPerc <- areaCovers %>%
  gather(key, val, vaatmark_pop, aapne_pop, semi_pop, vaatmark_nin, aapne_nin, semi_nin, lidarCover, skog) %>%
  mutate(type = ifelse(str_detect(key, "pop"), "pop",
    ifelse(str_detect(key, "nin"), "nin",
      ifelse(key == "lidarCover", "lidar", NA)
    )
  )) %>%
  mutate(ecosystem = ifelse(str_detect(key, "aapne"), "Naturlig åpne",
    ifelse(str_detect(key, "vaatmark"), "Våtmark",
      ifelse(str_detect(key, "semi"), "Semi-naturlig", NA)
    )
  )) %>%
  mutate(
    areaPerc = val / land * 100,
    areaPerc = ifelse(is.na(areaPerc), 0, areaPerc)
  ) %>%
  dplyr::select(SSBID, key, type, ecosystem, areaPerc)

```

```{r fig-coverage-map-enc, fig.height=6, fig.width=12}
#| message: false
#| warning: false
#| fig-cap: "Map of Norway showing coverage of different data sets per 10x10km gridcell (data from all three ecosystems combined)."

c1 <- ssb10km %>% 
  left_join(areaCoversPerc %>%
              filter(type == 'nin') %>%
              group_by(SSBID) %>%
              summarise(areaPerc = sum(areaPerc, na.rm=T)))  %>%
  ggplot() +
  geom_sf(aes(fill=areaPerc), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.3) +
  scale_fill_gradientn(colours = c('black', 'orange'),
                       name = '% cover',
                       limits=c(0, 2),
                       oob=scales::squish) +
  theme_void() +
  theme(legend.position = c(0.7, 0.4)) +
  ggtitle('A) NiN polygons with good condition')
#c1
c2 <- ssb10km %>% 
  left_join(areaCoversPerc %>%
              filter(type == 'pop') %>%
              group_by(SSBID) %>%
              summarise(areaPerc = sum(areaPerc, na.rm=T)))  %>%
  ggplot() +
  geom_sf(aes(fill=areaPerc), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.3) +
  scale_fill_gradientn(colours = c('black', 'orange'),
                       name = '% cover',
                       limits=c(0, 25),
                       oob=scales::squish) +
  theme_void() +
  theme(legend.position = c(0.7, 0.4)) +
  ggtitle('B) Population polygons')
#c2
c3 <- ssb10km %>% 
  left_join(areaCoversPerc %>%
              filter(type == 'lidar') %>%
              group_by(SSBID) %>%
              summarise(areaPerc = sum(areaPerc, na.rm=T)))  %>%
  ggplot() +
  geom_sf(aes(fill=areaPerc), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.3) +
  scale_fill_gradientn(colours = c('black', 'orange'),
                       name = '% cover',
                       limits=c(0, 100),
                       oob=scales::squish) +
  theme_void() +
  theme(legend.position = c(0.7, 0.4)) +
  ggtitle('C) LiDAR canopy height model')
#c3

coverageFig <- grid.arrange(c1, c2, c3, ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 

```

#### 7.7.2 Forest heights

Import forest heights per region-bioclimatic zone strata. @fig-coverage-map-forestheight shows that generally forest height increases when going from cold to warmer bioclimatic zones. The bar heights in @fig-coverage-map-forestheight are the X~0~ levels.

```{r importForestHeights}
#| message: false
skog_region_bioclim <- read_csv("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights_skog_climZoneRegion.csv")

names(skog_region_bioclim)[2:4] <- c("vegClimZone","skog","region_id")

skog_region_bioclim <- skog_region_bioclim %>%
  dplyr::select(-c('system:index','.geo'))

skog_region_bioclim <- cleanRegClim(skog_region_bioclim)

skog_region_bioclim$region <- factor(skog_region_bioclim$region, levels=regionlvl)
skog_region_bioclim$vegClimZoneLab <- factor(skog_region_bioclim$vegClimZoneLab, levels=vegclimzonelvl)

```

```{r fig-coverage-map-forestheight, fig.height=5, fig.width=10, fig.cap="Map of Norway showing 90th percentile forest heights per region-bioclimatic zone strata."}
#| message: false
bioClimReg %>%
  left_join(skog_region_bioclim) %>% 
  ggplot(aes(x = vegClimZoneLab, y = skog))+
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  coord_flip() +
  facet_wrap(.~region)+
  labs(y = "90th percentile forest height (m)",
       x = " ")


```

#### 7.7.3 Reference heights

Import the reference vegetation heights generated in GEE and define the upper limit of the ecological condition score per ecosystem type.

```{r importRefHeights}
#| message: false

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
    
    # Import median LiDAR heights for NiN polygons (references)
    dir <- '/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights/'
    refecosysttypeRaw <- readVegHeightFiles(dir, paste0(ecosysttype,'_ref')) %>%
    mutate(ref = chm) %>%
    dplyr::select(-'.geo', -'system:index', -chm)
    
    refecosysttypeRaw_tab <- cleanRegClim(refecosysttypeRaw) %>%
      group_by(region, vegClimZoneLab) %>%
      summarise(n = n())
    
    assign(paste0(ecosysttype,"rawtab"),refecosysttypeRaw_tab)
    
    # Add region and bioclim zones and calculate the median per strata. This will form the upper limit of the ecological condition score (i.e. good condition)
  refecosysttype <- cleanRegClim(refecosysttypeRaw) %>%
    group_by(region, vegClimZoneLab) %>%
    summarise(ref = median(ref, na.rm=T))
  
  
    # Export to file for reference
    refecosysttype %>% write.csv(paste0('../data/ref',ecosysttype,'.csv'), row.names =FALSE)
    
    assign(paste0('ref',ecosysttype), refecosysttype)

}
```

```{r fig-ref-wet-enc}
#| fig-cap: "Reference vegetation height in wetland ecosystems under the forest line in Norway. Numbers indicator the sample size."
#| message: false

refvaatmark <- read_csv("../data/refvaatmark.csv")

refvaatmarknr <- refvaatmark %>%
  left_join(vaatmarkrawtab)

refvaatmarknr$region <- factor(refvaatmarknr$region, levels = regionlvl)
refvaatmarknr$vegClimZoneLab <- factor(refvaatmarknr$vegClimZoneLab, levels = vegclimzonelvl)

refvaatmarknr %>%
  ggplot(aes(x = vegClimZoneLab, y = ref)) +
  geom_text(aes(label = n), hjust = -.5) +
  geom_bar(stat = "identity") +
  theme_bw(base_size = 12) +
  coord_flip() +
  scale_y_continuous(
    expand =
      expansion(mult = c(0, 0.5), add = c(.1, 0))
  ) +
  facet_wrap(. ~ region) +
  labs(
    y = "Reference vegetation height (m)",
    x = " "
  )
```

```{r fig-ref-open-enc, fig.cap="Reference vegetation height in natural open ecosystems under the forest line in Norway."}
#| message: false

refaapne <- read_csv('../data/refaapne.csv')


refaapnenr <- refaapne %>%
  left_join(aapnerawtab)

refaapnenr$region <- factor(refaapnenr$region, levels=regionlvl)
refaapnenr$vegClimZoneLab <- factor(refaapnenr$vegClimZoneLab, levels=vegclimzonelvl)

refaapnenr %>%
  ggplot(aes(x =vegClimZoneLab, y = ref))+
    geom_text(aes(label=n), hjust= -.5) +
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  coord_flip() +
    scale_y_continuous(
      expand =
        expansion(mult = c(0, 0.5), add = c(.1, 0))
    ) +
  facet_wrap(.~region)+
  labs(y = "Reference vegetation height (m)",
       x = " ")

```

```{r fig-ref-semi-enc, fig.cap="Reference vegetation height in semi-natural ecosystems under the forest line in Norway."}
#| message: false
refsemi <- read_csv('../data/refsemi.csv')

refseminr <- refsemi %>%
  left_join(semirawtab)

refseminr$region <- factor(refseminr$region, levels=regionlvl)
refseminr$vegClimZoneLab <- factor(refseminr$vegClimZoneLab, levels=vegclimzonelvl)

refseminr %>%
  ggplot(aes(x =vegClimZoneLab, y = ref))+
    geom_text(aes(label=n), hjust= -.5) +
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  coord_flip() +
  scale_y_continuous(
    expand =
      expansion(mult = c(0, 0.5), add = c(.1, 0))
  ) +
  facet_wrap(.~region)+
  labs(y = "Reference vegetation height (m)",
       x = " ")

```

#### 7.7.4 Population heights

Import the population vegetation heights generated in GEE.

```{r importPopVegHgt}
#| message: false

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
  
      ecosysttype <- ecosysttypes[i]

    # The wetland population dataset is exported differently from GEE than the two other population datasets.
  if(ecosysttype != "vaatmark"){
    
      # Import median LiDAR heights for GFA polygons for population measurement
        dir <- '/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights/'
    popecosysttypeHt <- readVegHeightFiles(dir, paste0(ecosysttype,'_pop'))  %>%
      mutate(pop = chm)%>%
      dplyr::select(-chm)
    
    # Turn into spatial objects using the .geo column in the CSV
    popecosysttype <- st_as_sf(bind_cols(popecosysttypeHt,geojsonsf::geojson_sf(popecosysttypeHt$.geo)))
    
  } else {
    
   # Import median LiDAR heights for GFA polygons for population measurement
    vaatmark_pop <- read_csv("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights/vaatmark_pop.csv") %>%
      mutate(pop = chm,
             region_id = id,
             ssbid=as.character(ssbid))%>%
      dplyr::select(-id, -chm, -type, -strat)
    
    # Turn into spatial objects using the .geo column in the CSV
    vaatmark_points <- st_as_sf(bind_cols(vaatmark_pop,geojsonsf::geojson_sf(vaatmark_pop$.geo)))
    
    # Metric crs
    vaatmark_pointsm <- st_transform(vaatmark_points, st_crs(regions))
    
    # Function to create a 30x30 m polygon square around each point
    create_square <- function(point, size = 20) {
      st_buffer(point, dist = size / 2, endCapStyle = "SQUARE")
      }
    # Apply the function to each point
    vaatmark_poly <- st_geometry(vaatmark_pointsm) %>% 
      lapply(create_square) %>% 
      st_sfc() %>%
      st_set_crs(st_crs(vaatmark_pointsm))
    
    # Lat long crs
    vaatmark_poly <- st_transform(vaatmark_poly, st_crs(vaatmark_points))
 
    # Combine the squares with the original attributes
    popecosysttype <- st_sf(vaatmark_points, geometry = vaatmark_poly)


  }
      
  
  popecosysttype <- cleanRegClim(popecosysttype)
  
  assign(paste0('pop',ecosysttype), popecosysttype)

  
}
```

#### 7.7.5 Combine datasets for heights

Combine the reference (good condition) and forest heights (poor condition) datasets with the population heights dataset per ecosystem type per strata. The forest heights will define the lower limit of the ecological condition score (ie. poor condition) for *vaatmark* and semi-natural land. However, for *naturlig åpen*, which is here represented as GRUK, we will manually set a threshold of 0.8 m as the poor condition. This is because encroachment in these areas may not culminate in a forested climax state, as for the others. 0.8 is used as an approximate height where we believe the nature types in this groups can be considered absolutely deteriorated.

```{r combineData}
#| message: false

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
  
  ecosysttype <- ecosysttypes[i]
  
  popecosysttype <- get(paste0("pop",ecosysttype))

  if(ecosysttype != "aapne"){
    
     # Combine median LiDAR heights for forest per region and bioclimatic zone combination with population heights.This will form the lower limit of the ecological condition score (ie. poor condition)
  popskogecosysttype <- popecosysttype %>%
    left_join(skog_region_bioclim, by = c('vegClimZoneLab','region'))
  
    
  } else {
     # Add the threshold for poor ecological condition in GRUK
      aapne_region_bioclim <- skog_region_bioclim
      aapne_region_bioclim$skog <- 0.8
    
        popskogecosysttype <- popecosysttype %>%
    left_join(aapne_region_bioclim, by = c('vegClimZoneLab','region'))
        
  }
  
  refecosysttype <- read_csv(paste0('../data/ref',ecosysttype,'.csv'))

  
  # Combine the reference heights, forest heights and population heights into one dataset
  ecosysttypeHts <- popskogecosysttype %>%
    as_tibble() %>% 
    dplyr::select(-geometry) %>%
    left_join(refecosysttype, by=c('vegClimZoneLab', 'region')) %>%
    gather(type, height, ref, pop, skog) %>%
    group_by(`system:index`, region, vegClimZoneLab, type) %>%
    summarise(height = mean(height)) %>%
    pivot_wider(values_from = height, names_from = type) %>%
    
    # If population height is less than the reference value, then it is automatically "good" condition - ie. it inherits the reference height so that the rescaled value will be 1
    mutate(pop = ifelse(pop < ref, ref, pop)) %>%
    drop_na(pop, ref)
  
  ecosysttypeHts$region <- factor(ecosysttypeHts$region, levels=regionlvl)
  ecosysttypeHts$vegClimZoneLab <- factor(ecosysttypeHts$vegClimZoneLab, levels=vegclimzonelvl)

  assign(paste0(ecosysttype,"Hts"), ecosysttypeHts)
  
}

```

## 8. Spatial units

The indicator values are estimated at the level of population polygons, but the reference levels are estimated for much larger homogeneous ecosystem areas (HEAs). Therefore the indicator should only be interpreted at the level of the [HEAs](#sec-HEA), or at least some rather large geographically aggregated scale, such as 10km grids.

## 9. Analyses

We will calculate the gjengroing indicator for each population polygon over Norway using a Sigmoid scaling function.

```{r sigmoidFunction}

# Define Sigmoid scaling function
scaleSigmoid <- function(variable){
  refLow <- min(variable)
  refHigh <- max(variable)
  thr <- (refHigh-refLow)/2
  indicator_LowHigh <- (variable - refLow)/(refHigh - refLow)
  indicator_LowHigh[indicator_LowHigh[] < 0] <- 0
  indicator_LowHigh[indicator_LowHigh[] > 1] <- 1
  indicator_sigmoid <- 100.68*(1-exp(-5*(indicator_LowHigh)^2.5))/100
  return (round(indicator_sigmoid, 4))
}

```

### 9.1 Scaled indicator values at polygon level {#sec-scaling}

We will calculate polygon-level indicator scores using the Sigmoid scaling functions. @fig-normalisedPlot show how the LiDAR vegetation heights (median for unique polygins) are normalised to the indicator scale. @fig-normalisationPlotNaturallyOpen shows that, for the naturally open areas at least, the X~0~ levels has the biggest impact in the indicator value (compared to X~0~).

```{r normalise}
#| message: false

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
    
    ecosysttypeHts <- get(paste0(ecosysttype,'Hts'))
    popecosysttype <- get(paste0('pop',ecosysttype))

    
  # Calcualte gjengroing index values
  ecosysttypeIndexPoly <- ecosysttypeHts  %>%
    # Gather into long format so that we can mutate the scaleSigmoid() function
    gather(type, height, ref, pop, skog) %>%
    group_by(`system:index`) %>%
    mutate(index = scaleSigmoid(height)) %>%
    # Because short vegetation is good condition, we must invert the scaled indicator
    mutate(index = 1-index) %>%
    # Get the indicator values for the population polygons only (ref and skog will be 1 and 0)
    filter(type == 'pop') %>%
    dplyr::select(-type, -height) %>%
    # Join with original data to get the actual median vegetation heights for each indicator score
    left_join(ecosysttypeHts %>% dplyr::select("system:index", pop, ref, skog)) %>%
    left_join(popecosysttype %>% dplyr::select("system:index", ssbid))
    
  # Make into spatial objects
  ecosysttypeIndexPolySpat <- popecosysttype %>%
    dplyr::select("system:index") %>%
    left_join(ecosysttypeIndexPoly) %>%
    filter(!is.na(index)) %>%
    # Transform to correct projection
    st_transform(st_crs(regions))

  assign(paste0(ecosysttype,"IndexPolySpat"), ecosysttypeIndexPolySpat)
    
}


```

```{r fig-normalisedPlot}
#| fig-cap: "Conversion (normalisation) of LiDAR vegetation heights to the indicator scale using spatially variable reference levels and a sigmoids transformation."
myColour <- "black"
mySize <- 8
myAlpha <- 0.7
myShape <- 21
low <- "red"
high <- "green"

aapneIndexPolySpat |>
  add_column(Ecosystem = "Naturally Open") |>
  bind_rows(semiIndexPolySpat |> add_column(Ecosystem = "Semi-natural")) |>
  bind_rows(vaatmarkIndexPolySpat|> add_column(Ecosystem = "Wetlands")) |>
  as_tibble() |>
  ggplot(aes(x = pop, y = index, 
      fill = index)) + geom_point(colour = myColour, 
      size = mySize, alpha = myAlpha, shape = myShape) + 
      ylab("Indicator values") + xlab("Median LiDar height (m)") + 
      scale_fill_gradient("Indicator values", low = low, 
        high = high) + scale_x_continuous(expand = expansion(mult = 0.2)) + 
      scale_y_continuous(expand = expansion(mult = 0.2)) + 
      guides(fill = "none") +
  facet_wrap(.~Ecosystem,
             scales = "free_x")

```

```{r fig-normalisationPlotNaturallyOpen}
#| fig-cap: |
#|   "Same figure as above, but looking only at naturally open areas with LiDAR height between zero and the upper reference value (0.8).
#|   This show that there is some, but very little, variation due to differences in the upper reference value (i.e. the X100)."
#| message: false
#| warning: false
aapneIndexPolySpat |>
  as_tibble() |>
  ggplot(aes(x = pop, y = index, 
      fill = index)) + geom_point(colour = myColour, 
      size = mySize, alpha = myAlpha, shape = myShape) + 
      ylab("Indicator values") + xlab("Median LiDar height (m)") + 
      scale_fill_gradient("Indicator values", low = low, 
        high = high) + scale_x_continuous(expand = expansion(mult = 0.2)) + 
      scale_x_continuous(limits = c(0,0.8)) + 
      guides(fill = "none") 

```

Here we will visualize the spatial variation in scaled gjengroings indicator values, as well as the vegetation heights for reference (good condition), indicator, and mature forest (poor condition) over the country. We could plot all the polygons, but it is computationally intensive and very difficult to visualize spatial variations over the entire country. Therefore we will calculate the area-weighted mean in values for each bioclimatic-region strata over the country.

```{r awm-strata}
#| message: false
#| warning: false
  
ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    ecosysttype <- ecosysttypes[i]

      ecosysttypeIndexPolySpat <- get(paste0(ecosysttype, "IndexPolySpat"))
            
      # Get area-weighted mean for reference, forest and population vegetation heights for each unique bioclimatic zone-region combination
      ecosysttypeIndexStrata <- bioClimReg %>% 
        #sample_n(10000) %>%
        st_join(ecosysttypeIndexPolySpat %>% 
                    mutate(area = as.numeric(st_area(geometry))), st_intersects, largest=T) %>%
        group_by(ID) %>%
        summarise_at(vars(pop, ref, skog, index), funs(weighted.mean(., w=area, na.rm=TRUE)))%>% 
        as_tibble() %>% 
        dplyr::select(-geometry)
      
       # Write out for import later
      ecosysttypeIndexStrata %>% write_csv(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Enchroachment_tempfiles/',ecosysttype,'IndexStrata.csv'))
      
      assign(paste0(ecosysttype, "IndexStrata"),ecosysttypeIndexStrata)
      
}

```

### 9.3 Scaled indicator values at 50km grid level

Using the polygon-level indicator scores, we will aggregate to 50km grid level to explore the spatial variation over Norway. We are doing this as an alternative way of visualizing the broad-scale patterns as presented in the section above where we used bioclimatic-elevation strata.

Here we will use a weighted average, but test out the eaTools::ea_spread function! It takes some time to run so best to do this overnight, or to parallelize in some way.

```{r awm50km}
#| message: false
#| warning: false

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]

      
    ecosysttypeIndexPolySpat <- get(paste0(ecosysttype,'IndexPolySpat'))

    # Aggregate polygon index scores to grid level using eaTools ea_spread function
    ecosysttypeIndexGrid <- eaTools::ea_spread(indicator_data = ecosysttypeIndexPolySpat,
                                            indicator = index,
                                            regions = ssb50km,
                                            groups = SSBID,
                                            threshold = 1) %>%
    mutate(index = w_mean, ssbid = ID) %>%
    dplyr::select(ssbid, index, sd)
  
    # Export
    #ecosysttypeIndexGrid %>% st_write(paste0('../data/',ecosysttype,'_index_grid.shp'), append=F)
    ecosysttypeIndexGrid %>% st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Enchroachment_tempfiles/',ecosysttype,'_index_grid.shp'), append=F, quiet = T)

    
    assign(paste0(ecosysttype, "IndexGrid"),ecosysttypeIndexGrid)
     
}
```

### 9.4 Scaled indicator values at regional level

::: callout-warning
This part is subject to change. One reviewer suggested using the SD from the indicator estimates across population polygons instead, to be consistent with the ecosystem condition framework.
:::

Now we will aggregate up to the regional level for final reporting. We will use the same method as in the section above, except here we will use a different method to calculate the uncertainty value around the indicator values. The ea_spread function in eaTools uses a bootstrapping method to calculate the standard error in indicator values when aggregating from the polygon to regional level. Because we have hundreds of thousands of polygons per region, the resulting standard errors are extremely small. Therefore we will use the standard deviation in reference values per region. The standard deviation, as a percentage of the average reference value is used to calculate the uncertainty in the scaled indicator value.

```{r awm-reg}
#| message: false
ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
      ecosysttype <- ecosysttypes[i]
  
      # Get the mean population, reference and forest heights per region for interpreting index values
      # The standard deviation is used later to define uncertainty around the indicator score
      ecosysttypeIndexPolySpat <- get(paste0(ecosysttype, "IndexPolySpat"))
      
      ecosysttypeHeightsRegion <- regions %>%
        st_join(ecosysttypeIndexPolySpat) %>% 
        as_tibble() %>%
        drop_na(index) %>%
        # Some errors in column names on the way but region.x and region.y are the same 
        mutate(region=region.x) %>%
        dplyr::select(-region.x, -region.y) %>%
        group_by(region) %>%
        summarise(pop_mean = mean(pop),
                  skog_mean = mean(skog),
                  ref_mean = mean(ref),
                  sd_ref = sd(ref),
                  sd_pop = sd(pop))
  
     # Aggregate polygon index scores to regional level using eaTools
      ecosysttypeIndexRegion <- eaTools::ea_spread(indicator_data = ecosysttypeIndexPolySpat,
                                              indicator = index,
                                              regions = regions,
                                              groups = region,
                                              threshold = 1) %>%
      mutate(index = w_mean, region = ID) %>%
      dplyr::select(region, index, sd) %>%
      left_join(ecosysttypeHeightsRegion)
    
      ecosysttypeIndexRegion %>% st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Enchroachment_tempfiles/',ecosysttype,'_index_region.shp'), append=F, quiet = T)
  
      assign(paste0(ecosysttype, "IndexRegion"),ecosysttypeIndexRegion)
  
      
}
                       

```

### 9.5 Validation of index score

::: callout-warning
This part is subject to change- One reviewer suggested validating the indicator by calculating indicator values for all NiN polygins in the reference area dataset, regardless of the recorded *tilstand*, and the plotting the indicator against the variable *rask suksesjon* (essentially a measure of encroachment done in the field). This will show if the indicator is able to separate areas based on some measure of ground truth.
:::

In the NiN data, the overall score for "tilstand" consists of several sub-scores. In semi-natural ecosystems, a variation of gjengroing is recorded as a sub-score (Rask suksesjon). However, for wetlands and natural open areas, there are no sub-scores for gjengroing.

To see how comparable the field-based condition scores from the NiN data are with the LiDAR-based height condition index score, we will repeat the gjengroing index calculation using reference heights from where the sub-category "Rask suksesjon" has a good condition.

```{r validation}
#| message: false
#| warning: false

nin <- st_read('/data/R/GeoSpatialData/Habitats_biotopes/Norway_Miljodirektoratet_Naturtyper_nin/Original/Naturtyper - Miljødirektoratets instruks/Naturtyper_nin_0000_norge_25833_FILEGDB.gdb', layer="naturtyper_nin_omr",
               quiet = T) %>%
    # Fix any invalid geometries
    mutate(validGeo = st_is_valid(SHAPE)) %>%
    filter(validGeo) %>%
    # Simplify ecosystem names
    mutate(hovedøkosystem = recode(hovedøkosystem, 
                                   "våtmark" = 'Vaatmark',
                                   "skog" = "Skog",
                                   "fjell" = "Fjell",
                                   "semi-naturligMark" = 'Semi-naturlig',
                                   "naturligÅpneOmråderILavlandet" = 'Naturlig aapne',
                                   "naturligÅpneOmråderUnderSkoggrensa" = 'Naturlig aapne'))

# Only select polygons where the sub-variable "Rask suksesjon" (7RA-BH or 7RA-SJ) have a score of 1 (Good) and get the IDs of those polygons. Also remove tree-covered semi-natural types.
nin <- nin %>%
  filter(grepl("7RA-BH_1|7RA-SJ_1",ninBeskrivelsesvariable),
         !(naturtype %in% c(
                              #Trees (oaks) or are tree covered
                              'Hule eiker', 
                              'Hagemark',
                              'Lauveng')
         ))

# Import median LiDAR heights for the polygons
    dir <- '/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/NiNvegHeights/'
nin_heights <- readVegHeightFiles(dir, "NiNveg") %>%
    mutate(ref = chm) %>%
    dplyr::select(-'.geo', -'system:index', -chm)

# Only semi-natural with good condition for Rask suksesjon
nin_heights <- nin_heights %>%
  filter(id %in% nin$identifikasjon_lokalId)
    
# Add region and bioclim zones and calculate the median per strata. This will form the upper limit of the ecological condition score (i.e. good condition)
refsemisub <- cleanRegClim(nin_heights) %>%
    group_by(region, vegClimZoneLab) %>%
    summarise(refsub = median(ref, na.rm=T))

# Compare with refsemi

refsemis <- refsemi %>%
  left_join(refsemisub)

refsemis$region <- factor(refsemis$region, levels=regionlvl)
refsemis$vegClimZoneLab <- factor(refsemis$vegClimZoneLab, levels=vegclimzonelvl)

# Combine with population heights and calculate new index scores

# Combine median LiDAR heights for forest per region and bioclimatic zone combination with population heights.This will form the lower limit of the ecological condition score (ie. poor condition)
  popskogsemi <- popsemi %>%
    left_join(skog_region_bioclim, by = c('vegClimZoneLab','region'))
  
  # Combine the reference heights, forest heights and population heights into one dataset
  semisHts <- popskogsemi %>%
    as_tibble() %>% 
    dplyr::select(-geometry) %>%
    left_join(refsemis, by=c('vegClimZoneLab', 'region')) %>%
    gather(type, height, refsub, pop, skog) %>%
    group_by(`system:index`, region, vegClimZoneLab, type) %>%
    summarise(height = mean(height)) %>%
    pivot_wider(values_from = height, names_from = type) %>%
    
    # If population height is less than the reference value, then it is automatically "good" condition - ie. it inherits the reference height so that the rescaled value will be 1
    mutate(pop = ifelse(pop < refsub, refsub, pop)) %>%
    drop_na(pop, refsub)
  
  semisHts$region <- factor(semisHts$region, levels=regionlvl)
  semisHts$vegClimZoneLab <- factor(semisHts$vegClimZoneLab, levels=vegclimzonelvl)

   # Calcualte gjengroing index values
  semisIndexPoly <- semisHts  %>%
    # Gather into long format so that we can mutate the scaleSigmoid() function
    gather(type, height, refsub, pop, skog) %>%
    group_by(`system:index`) %>%
    mutate(index = scaleSigmoid(height)) %>%
    # Because short vegetation is good condition, we must invert the scaled indicator
    mutate(index = 1-index) %>%
    # Get the indicator values for the population polygons only (ref and skog will be 1 and 0)
    filter(type == 'pop') %>%
    dplyr::select(-type, -height) %>%
    # Join with original data to get the actual median vegetation heights for each indicator score
    left_join(semisHts %>% dplyr::select("system:index", pop, refsub, skog)) %>%
    left_join(popsemi %>% dplyr::select("system:index", ssbid))
    
  # Make into spatial objects
  semisIndexPolySpat <- popsemi %>%
    dplyr::select("system:index") %>%
    left_join(semisIndexPoly) %>%
    filter(!is.na(index)) %>%
    # Transform to correct projection
    st_transform(st_crs(regions))

      # Get area-weighted mean for reference, forest and population vegetation heights for each unique bioclimatic zone-region combination
      semisIndexStrata <- bioClimReg %>% 
        #sample_n(10000) %>%
        st_join(semisIndexPolySpat %>% 
                    mutate(area = as.numeric(st_area(geometry))), st_intersects, largest=T) %>%
        group_by(ID) %>%
        summarise_at(vars(pop, refsub, skog, index), funs(weighted.mean(., w=area, na.rm=TRUE)))%>% 
        as_tibble() %>% 
        dplyr::select(-geometry) %>%
        rename(index_sub=index)
      
# Compare
semisIndexStrata <- semisIndexStrata %>%
  left_join(semiIndexStrata, by="ID") %>%
  left_join(bioClimReg)
  
  
```

## 10. Results

The enchroachment indicator is visualised at three different spatial scales below, per bioclimatic sone (@fig-multiple-maps-enc), per 50km grid cell (@fig-grid-level-enc) and per region (@fig-regional-level-enc). @fig-multiple-maps-enc show what can be considered the most correct visualisation of the indicator values across Norway. Wetlands and GRUK areas are generally in good condition, according to @fig-grid-level-enc. However, @fig-grid-level-enc show that the GRUK areas are on a worse condition, so perhaps the colors in @fig-multiple-maps-enc are misleading in some way? Semi-natural areas are more varied, with lower condition found in the central boreal zone in south and western Norway and south boreal zone in Central Norway (@fig-multiple-maps-enc).

The gjengroing condition indicator scores are on average above 0.8 and therefore indicate a good overall condition in Norway (@fig-regional-level-enc-forest). Østlandet comes out best for våtmark and semi-naturlig åpne ecosystems. Nord-Norge has poorest condition for semi-naturlig åpne ecosystems, while vestlandet has the poorest scores for våtmark."

### 10.1 Scaled indicator values at the level of homogeneous ecosystem areas {#sec-HEA}

```{r fig-multiple-maps-enc, fig.width=9, fig.height=8}
#| fig-cap: "Maps of variable and indicator values, as well as reference values, for unique homogeneous ecosystem areas. For the unscaled variables the legend is truncated at 5 m to ensure the same colour gradient for all maps."
#| message: false
  
# Import datasets
ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    ecosysttype <- ecosysttypes[i]

    ecosysttypeIndexStrata <- read_csv(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Enchroachment_tempfiles/',
                                              ecosysttype,'IndexStrata.csv'))
    
    assign(paste0(ecosysttype, "IndexStrata"),ecosysttypeIndexStrata)    
}


# Make plots of indicator heights and scaled condition values for each strata polygon

theme_legend_1 <- theme(legend.key.size = unit(0.25, 'cm'), #change legend key size
                        legend.key.height = unit(0.25, 'cm'), #change legend key height
                        legend.key.width = unit(0.25, 'cm'), #change legend key width
                        legend.title = element_text(size=6), #change legend title font size
                        legend.text = element_text(size=6), #change legend text font size
                        legend.position = c(0.8, 0.4)) #change legend position

makeStrataHeightMap <- function(data, var, title, limits){
  p <- bioClimReg %>%
    left_join(data, by = c('ID'))  %>%
    mutate(response = .[[var]]) %>%
    ggplot() + 
    geom_sf(aes(fill = response), color=NA)+
      scale_fill_gradientn(colors=viridis::viridis(10),
                           limits = limits,
                           oob = scales::squish,
                           name = 'Veg ht (m)')+
      ggtitle(title) +
      theme_void() +
    theme(plot.title = element_text(size=9)) +
    theme_legend_1
    
  return (p)
}

makeStrataIndicatorMap <- function(data, title){
  p <- bioClimReg %>%
    left_join(data, by = c('ID'))  %>%
    ggplot() + 
    geom_sf(aes(fill = index), color=NA)+
      scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                           limits = c(0,1),
                           name = 'Index')+
      ggtitle(title) +
      theme_void()+
    theme(plot.title = element_text(size=9)) +
    theme_legend_1
    
  return (p)
}

v1 <- makeStrataIndicatorMap(vaatmarkIndexStrata, 'A) Våtmark scaled indicator')
v2 <- makeStrataHeightMap(vaatmarkIndexStrata, "ref", 'B) Våtmark reference height', c(0,5))
v3 <- makeStrataHeightMap(vaatmarkIndexStrata, "pop", 'C) Våtmark vegetation height', c(0,5))

a1 <- makeStrataIndicatorMap(aapneIndexStrata,  'E) Naturlig åpne scaled indicator')
a2 <- makeStrataHeightMap(aapneIndexStrata, "ref", 'F) Naturlig åpne reference height', c(0,5))
a3 <- makeStrataHeightMap(aapneIndexStrata, "pop", 'G) Naturlig åpne vegetation height', c(0,5))

s1 <- makeStrataIndicatorMap(semiIndexStrata,  'I) Semi-naturlig scaled indicator')
s2 <- makeStrataHeightMap(semiIndexStrata, "ref", 'J) Semi-naturlig reference height', c(0,5))
s3 <- makeStrataHeightMap(semiIndexStrata, "pop", 'K) Semi-naturlig vegetation height', c(0,5))


strataHeightPlot <- grid.arrange(v1,v2,v3,
                                 a1,a2,a3, 
                                 s1,s2,s3, 
                                 ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 

```

### 10.2 Scaled indicator values at 50km grid level

```{r fig-grid-level-enc, fig.cap="Maps displaying scaled encroachment indicator values on a 50 km grid level"}
#| message: false

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
  
    ecosysttypeIndexGrid <- st_read(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Enchroachment_tempfiles/',ecosysttype,'_index_grid.shp'),
                                    quiet = T) 
  
    assign(paste0(ecosysttype, "IndexGrid"),ecosysttypeIndexGrid)
     
}

vGrid1 <- vaatmarkIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('A) Våtmark gjengroing condition')

vGrid2 <- aapneIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('B) Naturlig åpne condition')

vGrid3 <- semiIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('C) Semi-naturlig condition')



indexGridFig <- grid.arrange(vGrid1, vGrid2, vGrid3, ncol=3, widths=c(1,1,1),
                             padding = unit(0, "line"), newpage = T) 

```

### 10.3 Scaled indicator values at regional level

```{r fig-regional-level-enc-forest, fig.cap="Forest plot displaying scaled encroachment indicator values on a regional level"}
#| message: false
#| warning: false
ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
      ecosysttype <- ecosysttypes[i]
  
      ecosysttypeIndexRegion <- st_read(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/Enchroachment_tempfiles/',ecosysttype,'_index_region.shp'), quiet = T)
  
      assign(paste0(ecosysttype, "IndexRegion"),ecosysttypeIndexRegion)
}

# Join into a table to present values
vaatmarkTable <- vaatmarkIndexRegion %>% as_tibble() 
aapneTable <- aapneIndexRegion %>% as_tibble() 
semiTable <- semiIndexRegion %>% as_tibble() 

# Join ecosystem types and calculate uncertainty
indicatorTable <- vaatmarkTable %>% mutate(Ecosystem = 'Våtmark') %>%
  bind_rows(aapneTable %>% mutate(Ecosystem = 'Naturlig åpne')) %>%
  bind_rows(semiTable %>% mutate(Ecosystem = 'Semi-naturlig')) %>%
  # Calculate the error based on the standard deviation in population polygon heights as a percentage of the population height, and multiply by index score
  mutate(sd = (sd_pop/pop_mean)*index)

# Format the table for presentation
indicatorTable_formatted <- regions %>%
  left_join(indicatorTable) %>% as_tibble() %>%
  dplyr::select(-geometry)  %>%
  dplyr::select( region, Ecosystem, index, sd, pop_mean, ref_mean, skog_mean) %>%
  mutate_if(is.numeric, round, 2)
names(indicatorTable_formatted) <- c( "Region", "Ecosystem",
                                      "Scaled indicator",  "Scaled Std.dev",
                                      "Indicator height","Reference height",
                                      "Mature forest height")

# Use knitr to visualize
knitr::kable(indicatorTable_formatted)

# Make plots of regional index values
getIndicatorPlot <- function(label){
  regions %>%
    left_join(indicatorTable %>%
                filter(Ecosystem == label)) %>%
    mutate(lowError = index-sd, 
           upError = index+sd,
           upError = ifelse(upError > 1, 1, upError)) %>%
    ggplot(aes(y=region, x=index)) +
    geom_point() +
    geom_segment(aes(yend=region, x=lowError, xend=upError)) +
    coord_cartesian(xlim=c(0,1)) +
    geom_vline(xintercept = 1) +
    geom_vline(xintercept = 0) +
    labs(x = 'Tilstandsverdi') +
    theme(legend.position = c(0.7, 0.4),
          axis.title.y=element_blank()) +
    ggtitle(label) 
}

i1 <- getIndicatorPlot('Våtmark')
i2 <- getIndicatorPlot('Naturlig åpne')
i3 <- getIndicatorPlot('Semi-naturlig')

grid.arrange(i1, i2, i3, ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 
```

```{r fig-regional-level-enc, fig.cap="Maps displaying scaled encroachment indicator values on a regional level"}
#| message: false
#| warning: false
# Make maps of regional index values
getIndicatorMap <- function(data, label){
  regions %>%
    left_join(data) %>%
    ggplot() +
    geom_sf(aes(fill=index)) +
    scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                         limits = c(0,1))+
    ggtitle(label)+
    theme_void()+
    theme(legend.position = c(0.7, 0.4))
}

m1 <- getIndicatorMap(vaatmarkTable, 'A) Våtmark')
m2 <- getIndicatorMap(aapneTable, 'B) Naturlig åpne')
m3 <- getIndicatorMap(semiTable, 'C) Semi-naturlig')

grid.arrange(m1, m2, m3, ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 
```

### 10.4 Validation of index score

```{r fig-validation-enc, fig.cap="Scatter plot displaying reference heights for good condition according to NiN field-mapping ecological condition overall score and sub-score for Rask suksesjon in semi-natural ecosystems"}

refsemis %>%
  ggplot(aes(x = ref, y = refsub, color = vegClimZoneLab, shape = region)) +
  geom_point(size = 3) + 
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "gray") +
  scale_color_viridis_d() +  # Color palette for vegClimZoneLab
  labs(x = "Vegetation height (m) overall good condition",
       y = "Vegetation height (m) sub-score good condition",
       color="Bioclimatic zone",
       shape="Region")+
  scale_x_continuous(lim=c(0,1.1))+
  scale_y_continuous(lim=c(0,1.1))
```

The scatter plot shows that in general, there is a good agreement between the overall good condition reference heights and the ones with good condition in the sub-category "Rask suksesjon". For the strata Sørlandet-Mellomboreal sone and Sørlandet-Sørboreal sone, the reference vegetation heights are 50-70 cm higher when using the overall condition score than when using only the sub-score that should be the field-based estimate of gjengroing. This means that for these two strata, calculated index scores for gjengroing in semi-natural ecosystems will in general have better condition scores when using heights from polygons with overall good condition as reference. However, when averaged across strata, this score is not apparent (see next figure).

These results suggest that, at least for semi-natural ecosystems, using polygons with an overall good condition score will still give reference heights that are suitable for calculating the gjengroing index.

```{r validation-enc-index, fig.cap="Scatter plot displaying reference heights for good condition according to NiN field-mapping ecological condition overall score and sub-score for Rask suksesjon in semi-natural ecosystems"}

semisIndexStrata %>%
  ggplot(aes(x = index, y = index_sub, color = vegClimZoneLab, shape = region)) +
  geom_point(size = 3) + 
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "gray") +
  scale_color_viridis_d() +  # Color palette for vegClimZoneLab
  labs(x = "Index overall good condition",
       y = "Index sub-score good condition",
       color="Bioclimatic zone",
       shape="Region")
```

## 12. Export file

::: callout-warning
This part is subject to change.
:::

<!--# For the sake of the current project I think we can just export the regional estimates. We can also export the HEA level indicator map, but the polyggon level (occurence level) data I think is best left as a temporary calulcation file -->

We will export gjengroing indicator values at three levels: - polygon level - 50km grid level - regional level

```{r export}
#| eval: false

ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
    ecosysttype <- ecosysttypes[i]
      
    # Polygon level
    ecosysttypeIndexPolySpat <- get(paste0(ecosysttype,"IndexPolySpat"))
    ecosysttypeIndexPolySpat  %>%
    #mutate(area = as.numeric(st_area(geometry)))%>% 
    #filter(area > 7500) %>%
    mutate(id = `system:index`,
           region = region, 
           vegZn = vegClimZoneLab) %>%
    dplyr::select(-"system:index", -vegClimZoneLab, -elevation) %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index.shp"), append=FALSE)
      
    # Grid level
    ecosysttypeIndexGrid <- get(paste0(ecosysttype,"IndexGrid"))
    ecosysttypeIndexGrid %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index_grid.shp"), append=FALSE)
      
    # Region level
    ecosysttypeIndexRegion <- get(paste0(ecosysttype,"IndexRegion"))
    ecosysttypeIndexRegion %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index_region.shp"), append=FALSE)
      

}
```
