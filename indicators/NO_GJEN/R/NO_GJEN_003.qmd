---
title: "Enchroachment LiDAR"
format: 
  html:
    embed-resources: true
author:
  - name: Ida M. Mienna              # Enter name
    email: ida.mienna@nina.no  # Enter email
    affiliations:
      - id: myID
        name: The Norwegian Institute for Nature Research (NINA) # Enter affiliations
  - name: Zander Venter              #  Enter subsequent authors like this, or remove if not relevant
    affiliations:
      - ref: myID               # To reuse affiliations referecen the id like this
date: August 12, 2024 # Enter date 
callout-icon: false
---

<!--# This is a template for how to document the indicator analyses. Make sure also to not change the order, or modify, the headers, unless you really need to. This is because it easier to read if all the indicators are presented using the same layout. If there is one header where you don't have anything to write, just leave the header as is, and don't write anything below it. If you are providing code, Be careful to annotate and comment on every step in the analysis. Before starting it is recommended to fill in as much as you can in the metadata file. This file will populate the initial table in your output.-->

<!--# Load all you dependencies here -->

```{r setup}
#| include: false
library(knitr)
library(sf)
library(tidyverse)
library(gridExtra)
library(kableExtra)
library(RColorBrewer)
library(flextable)
library(here)

# Set global variable defining whether you want to run everything from scratch (very long runtime) or use pre-exported data (short runtime)
runFromScratch <- FALSE

knitr::opts_chunk$set(echo = TRUE, message=FALSE, warning=FALSE)


```

```{r source}
#| echo: false
source(here::here("R/_common.R"))

here::here()
```

```{r}
#| echo: false
meta <- readxl::read_xlsx("../metadata.xlsx")
st <- meta |>
  filter(Variable == "status") |>
  pull(Value)
version <- meta |>
  filter(Variable == "Version") |>
  pull(Value)
auth <- meta |>
  filter(Variable == "authors") |>
  pull(Value)
year <- meta |>
  filter(Variable == "yearAdded") |>
  pull(Value)
name <- year <- meta |>
  filter(Variable == "indicatorName") |>
  pull(Value)
url <- meta |>
  filter(Variable == "url") |>
  pull(Value)

meta <- meta |>
  mutate(Variable = case_match(Variable,
    "indicatorID" ~ "Indicator ID" ,
    "indicatorName" ~ "Indicator Name",
    "country" ~ "Country",
    "continent" ~ "Continent",
    "ECT" ~ "Ecosystem Condition Typology Class",
    "yearAdded" ~ "Year added",
    "yearLastUpdate" ~ "Last update",
    .default = Variable
   )
  ) |>
  filter(Variable != "authors")

```

<!--# The following parts are autogenertaed. Do not edit. -->

::: {layout-ncol="3"}
```{r}
#| echo: false
#| results: asis
status(st)
```

::: {.callout-note style="background: cornsilk;"}
## Recomended citation

`r paste(auth, year, name, "v.", version, "ecRxiv", url, sep=" ")`
:::

::: {.callout-note style="background: khaki;"}
## Version

`r version`
:::
:::

```{r tbl-meta}
#| tbl-cap: 'Indicator metadata'
#| echo: false
#| warning: false

meta |>
  select(Variable, Value) |>
  kbl(col.names = NULL) 

```

# Gjengroing

<!--# Replace 'indicator name' with your the actual indicator name -->

<br />

<!--# Don't remove these three html lines -->

<br /> <br />

<hr />

<!--# Document you work below.  -->

## 1. Introduction

<!--# Describe the indicator in general terms. It is a good idea to include a bullet point list of the spesific steps in the workflow -->

From [ecosystemCondition](https://github.com/NINAnor/ecosystemCondition/blob/main/gjengroing.Rmd):

The Norwegian word "gjengroing" is directly translated to "regrowing" in English. The gjengroing indicator describes the regrowth of woody vegetation (trees and bushes) in open ecosystems (wetland, semi- and naturally open areas) across Norway. We will use a spatial reference approach where reference areas define good or optimal vegetation regrowth heights.

The workflow spans two platforms including RStudio and Google Earth Engine (GEE). To reproduce this workflow you will need a GEE account and access to the NINA RStudio and R/GeoSpatialData servers.

## 2. About the underlying data

<!--# Describe the data you have used, it's origin, biases, avaiabilit ect.-->

We rely on the following datasets:

-   [Nature type polygons](https://kartkatalog.miljodirektoratet.no/Dataset/Details/2031) are used to identify reference areas with good ecological condition.
-   NIBIO's [AR5](https://kartkatalog.geonorge.no/metadata/arealressurskart-fkb-ar5-arealtyper/280bbd7a-5ce9-4c83-9e15-ac162cabd8a6) is used as the population sample for each ecosystem type. The population sample are the areas used to determine ecological condition relative to the reference areas. We also use the AR5 data to identify forest surrounding the population polygons for defining the lower limit of ecological condition index (i.e.. poor condition),
-   LiDAR-derived digital elevation model from Kartverket's [høydedata](https://hoydedata.no/LaserInnsyn/). This includes both a terrain (DTM) and surface model (DSM). We calculate the canopy height model (DSM - DTM) to get the height of objects above the ground. From this we remove buildings, and what remains is vegetation - mostly trees but also some bushes or smaller woody plants.
-   Kartverket's [national 10m elevation model](https://kartkatalog.geonorge.no/metadata/dtm-10-terrengmodell-utm32/fd851873-f363-46f9-9fc6-bb1b403575df). We use this to stratify reference (good condition) and forest (poor condition) heights by elevational band. This is done in combination with bioclimatic zones - see next point.
-   Moen's [bioclimatic zones](https://artsdatabanken.no/Pages/181901/Bioklimatiske_soner). We use this to stratify reference (good condition) and forest (poor condition) heights by bioclimatic (also referred to as vegetation/climatic) zones.
-   [FKB building footprints](https://kartkatalog.geonorge.no/metadata/fkb-bygning/8b4304ea-4fb0-479c-a24d-fa225e2c6e97) are used to isolate vegetation in the LiDAR height data.
-   A [European satellite-based map](https://www.nature.com/articles/s41893-020-00609-y) of forest clear cuts is used for identifying AR5 forest patches in near-climax successional stages.
-   The [SSB 10km grid](https://kartkatalog.geonorge.no/metadata/statistisk-rutenett-5000m/32ac0653-d95c-446c-8558-bf9b79f4934e) is used for visualization purposes.
-   The regional delineation for Norway (five regions) are used for aggregating and reporting gjengroing condition values."

### 2.1 Spatial and temporal resolution

<!--# Describe the temporal and spatial resolution of the data used-->

The index will cover the mainland of Norway. The analysis will be stratified by (1) åpne and (2) våtmark ecosystems. The former includes both semi-naturlig mark and naturlig åpne områder under skoggrensa (due to the fact that AR5 does not differentiate these), and the latter includes våtmark only. The LiDAR data cover a range of years and therefore the indicator represents conditions for circa 2010 to 2021."

"Temporal coverage: Circa 2010 to 2021. This is a single snapshot and not a change analysis. In the future, when LiDAR data has been repeated across the country, it may be possible to do a change assessment. In addition, the use of optical or radar satellite imagery may serve as a proxy for vegetation height using machine learning. This will allow for annual updates, depending on the uncertainty in the satellite-based maps of vegetation height.

### 2.2 Original units

<!--# What are the original units for the most relevant  variables in the data-->

From [ecosystemCondition](https://github.com/NINAnor/ecosystemCondition/blob/main/gjengroing.Rmd):

The original units for ecological condition are meters. This is the height of the vegetation within reference, polygon and forest areas.

### 2.3 Additional comments about the dataset

<!--# Text here -->

## 3. Indicator properties

### 3.1. ECT

<!--# Describe the rationale for assigning the indicator to the ECT class -->

ECT: Structural state characteristic

Ecosystem: Våtmark og Semi-/Naturlig-åpne

Egenskap: Funksjonell sammensetning innen trofiske nivåer

### 3.2. Ecosystem condition characteristic

<!--# Describe the ecosystem condition characteristic represneted in the indicator. See 10.3897/oneeco.6.e58218 for information on what these characteristics might be. -->

### 3.3. Other standards

<!--# Add text about other spesific standards, e.g. natinoal standards, and how the indicator relates to these -->

### 3.4. Collinearities with other indicators

<!--# Describe known collinearities with other metrices (indicators or variables) that could become problematic if they were also included in the same Ecosystem Condition Assessment as the indicator described here. -->

There is possibly a collinearity with the [primary production indicator](#NDVI-indicator-natopen) (primærproduksjon). The primary production indicator uses the normalized difference vegetation index (NDVI) as a proxy for vegetation production. NDVI can be correlated with vegetation height and consequently yield similar results to the LiDAR-based gjengroing indicator.

## 4. Reference condition and values

### 4. 1. Reference condition

<!--# Define the reference condition (or refer to where it is defined). Note the destinction between reference condition and reference values 10.3897/oneeco.5.e58216  -->

The reference state is defined as one where åpne ecosystems are indeed open, with little to no woody encroachment. For natural ecosystems this reflects a state where climate warming, wetland drainage, and alien species etc have not led to any net loss of these nature types and their internal functioning. For semi natural ecosystems it reflects a state where traditional husbandry is keeping the ecosystems open due to grazing and hay making.

### 4. 2. Reference values

#### 4.2.1 Minimum and maximum values

<!--# Describe the reference values used to set the lower and upper limits on the normative indicator scale. Why was the current option chosen and how were the reference values quantified? If the reference values are calculated as part of the analyses further down, please repeat the main information here. -->

The methodology used to calculate the *gjengroing* indicator is outlined in the schematic below. The workflow in the schematic is conducted for all reference and population polygons in Norway and repeated for each ecosystem type (våtmark, naturlig åpne og semi-naturlig), respectively. The indicator values are aggregated to a 50km grid and regional level at the end. The individual steps are discussed in turn in the following subsections.

```{r enc-workflow, fig.cap="Schematic illustration of how the encroachment indicator is calculated. The lower bound for poor condition is set by LiDAR heights from mature forest surrounding the population polygon. The upper bound for good condition is set by regional median LiDAR heights within NiN polygons in the same bioclimatic-elevation zone as the population polygon.", out.width='70%', echo=FALSE}
knitr::include_graphics("../img/gjengroing_schematic.jpg")
getwd()
```

The NiN polygons including "Våtmark", "Naturlig åpne områder under skoggrensa" and "Semi-naturlig mark" with good ecological condition are used to define a reference gjengroing state. We use the aggregated "Tilstand" variable assigned to each NiN polygon. The 50th percentile of LiDAR-derived vegetation heights within these polygons is used to define the upper limit (ie. 1) of the scaled indicator value. We cannot define local reference values based on proximity, because the NiN polygons are spatially biased and not close to all population polygons. Therefore we calculate regional reference values using regions and bioclimatic zones as stratification. We calculate the mean reference value for each unique combination of region-bioclimatic zone. When calculating the index for each population polygon, the reference value is inherited from the region-bioclimatic zone it falls within.

Once we have the reference vegetation height for a given ecosystem type and region-bioclimatic zone, we need to define the minimum (or worst/bad) condition. We use the 90th percentile of LiDAR-derived vegetation heights within nasjonalt grunnkart skog polygons to define a climax vegetation successional stage where gjengroing is at its most extreme, and thus wahat is the poor ecological condition for naturally open areas. In order not to include forest patches that have recently been harvested, we mask out any forest which has been clear-cut since 1986. Here, 1986 is a hard limit defined by the clear-cut dataset which was based on Landsat imagery. Therefore we can be assured that we are measuring forest that is at least 35 years old.

To define the ecological condition of the population polygon, we measure 50th percentile of LiDAR-derived vegetation height. **!!! As a reminder, we use AR5 polygons that have types that are approximately compatible with the NiN ecosystem types. For våtmark we use the AR5 polygons defined as "Myr". For åpne ecosystems we use the AR5 polygons defined as either "Åpent fastmark" or "Innmarksbeite". !!!**

We acknowledge that the AR5 data set has several shortcomings in terms of lags in update frequency and with precision in the maps themselves. This indicator will therefore benefit strongly from new ecosystem delineation maps, that update more frequently, and preferably once that can differentiate between semi-natural and naturally open ecosystems.

The vegetation height percentiles are then scaled to between 0 and 1 using a sigmoid transformation [Oliver at al. (2021)](https://www.sciencedirect.com/science/article/pii/S1470160X21000066).

#### 4.2.2. Threshold value for defining *good ecological condition (if relevant)*

<!--# Describe the different reference values here and the justification for using these -->

#### 4.2.3. Spatial resolution and validity

<!--# Describe the spatial resolution of the reference values. E.g. is it defined as a fixed value for all areas, or does it vary. Also, at what spatial scale is the reference values valid? For example, if the reference value has a regional resolution (varies between regions), it might mean that it is only valid and correct to use for scaling local variable values that are first aggregated to regional scale. However, sometimes the reference value is insensitive to this and can be used to scale variables at the local (e.g. plot) scale.  -->

## 5. Uncertainties

<!--# Describe the main uncertainties or sources of error in the indicator or the underlying data. -->

For the indicator map at the polygon level there is no uncertainty associated with the indicator values. For aggregated indicator values (e.g. for 50km grid and regions), the uncertainty in the indicator value is calculated from the spatial variation in the polygon-level reference height values. We could use the alternative of calculating the spatial variation in the indicator values via bootstrapping using the EAtools package. However, given the extreme number of population polygons, the uncertainty values are extremely small and therefore we choose to use the standard deviation in reference vegetation heights, converted to the indicator scale.

## 6. References

<!--# You can add references manually or use a citation manager and add intext citations as with crossreferencing and hyperlinks. See https://quarto.org/docs/authoring/footnotes-and-citations.html -->

Links to data and resources are provided with hyperlinks in-line.

## 7. Datasets

<!--# Describe the unique datasets seperately under seperate headers (Dataset A, Dataset B, etc.-->

There are several datasets which are used in GEE which will not be imported into the R session here. These datasets have been obtained from the source and ingested into GEE by Zander Venter or Vegar Bakkestuen with the help of Miljødata section at NINA. They include

-   [Grunnkart for bruk i arealregnskap](https://nibio.brage.unit.no/nibio-xmlui/handle/11250/3120510)
-   [LiDAR-derived digital elevation model from høydedata](https://hoydedata.no/LaserInnsyn/).
-   [Kartverket's national 10m elevation model](https://kartkatalog.geonorge.no/metadata/dtm-10-terrengmodell-utm32/fd851873-f363-46f9-9fc6-bb1b403575df)
-   [FKB building footprints](https://kartkatalog.geonorge.no/metadata/fkb-bygning/8b4304ea-4fb0-479c-a24d-fa225e2c6e97)
-   [European forest clear-cut map](https://www.nature.com/articles/s41893-020-00609-y)

The remaining datasets will be imported into the R session.

### 7.1 Regions

<!--# Describe the main dataset, typicaly the one containing the variable of (most) interest. Change the header from Dataset A to the name of the actuall dataset. -->

"

The regional delineation for Norway (five regions) are used for aggregating and reporting gjengroing condition values.

```{r}

regions <- sf::st_read("../data/regions.shp")

# Some issues with the letter "ø"
regions$region[regions$id == 3] <- "Østlandet"
regions$region[regions$id == 5] <- "Sørlandet"

regionlvl <- c("Nord-Norge", "Midt-Norge", "Vestlandet", "Østlandet", "Sørlandet")

regions$region <- factor(regions$region, levels=regionlvl)

```

"

### 7.2 SSB 10 and 50km grids

<!--# Describe additional datasets in a similar was as above. Deleteor add ned subheaders as needed. -->

"

The [SSB 10km and 50km grids](https://kartkatalog.geonorge.no/metadata/statistisk-rutenett-5000m/32ac0653-d95c-446c-8558-bf9b79f4934e) are used for visualizing the distribution of available data and for aggregating gjengroing index scores.

```{r}
ssb10km <- st_read('/data/R/GeoSpatialData/Population_demography/Norway_SSB/Original/ssb_10km/ssb10km.shp')%>%
  # mutate the id value so that it aligns with the data coming from GEE
  mutate(SSBID = as.numeric(SSBID)/1000)
# Transform to the correct projection
ssb10km <- st_transform(ssb10km, st_crs(regions))

ssb50km <- st_read('/data/R/GeoSpatialData/Population_demography/Norway_SSB/Original/ssb_50km/ssb50km.shp')%>%
  # mutate the id value so that it aligns with the data coming from GEE
  mutate(SSBID = as.numeric(SSBID)/1000)
# Transform to the correct projection
ssb50km <- st_transform(ssb50km, st_crs(regions))
```

"

### 7.3 Bioclimatic regions

The [Moen's bioclimatic regions](https://data.artsdatabanken.no//Natur_i_Norge/Natursystem/Beskrivelsessystem/Regional_naturvariasjon/Bioklimatisk_sone) are imported from NINA R/GeoSpatialData/ server.

```{r}

bioclim <- st_read('/data/R/GeoSpatialData/BiogeographicalRegions/Norway_PCA_klima/Converted/Soner2017.shp')
bioclim <- st_transform(bioclim, "EPSG:4326")

# The file is in tiles. Will therefore dissolve these by Sone_navn
bioclim <- bioclim %>%
  group_by(Sone_navn) %>%
  summarise(geometry = st_union(geometry))

# Add unique code for each name called KLASSE
bioclim <- bioclim %>%
  mutate(KLASSE=as.numeric(as.factor(Sone_navn))) %>%
  rename(NAVN="Sone_navn")

vegclimzonelvl <- c("Lavalpin sone (LA)", "Nordboreal sone (NB)", "Mellomboreal sone (MB)", "Sørboreal sone (SB)", "Boreonemoral sone (BN)")

bioclim$NAVN <- factor(bioclim$NAVN, levels=vegclimzonelvl)

# Export the file
if(runFromScratch){
  st_write(bioclim, '../data/bioclimreg.shp', append=FALSE)
}

```

### 7.4 ASO

The ASO dataset is used as population polygons for semi-natural areas. The dataset consists both of open nature types (e.g. slåttemark) and non-open nature types (e.g. hagemark). The types that are non-open will thus be excluded from the dataset before exporting to Google Earth Engine.

```{r}
ASO <- st_read("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/ASO/ASO_naturområder_21-23.shp")

ASO <- ASO[ASO$naturtype %in% c("Naturbeitemark", "Semi-naturlig eng", "Slåttemark"),]

st_write(ASO, "/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Data/ASO/ASO_open.shp")

```

### 7.4 Reference data: NiN polygons

[NiN polygons](https://kartkatalog.miljodirektoratet.no/dataset/Details/2031) are imported here from the NINA servers:

```{r}

# Function to extra hovedtype
extract_hovedtype <- function(text) {
  matches <- str_match_all(text, "NA_(.*?)-")
  unique(matches[[1]][, 2])
}

nin <- st_read('/data/R/GeoSpatialData/Habitats_biotopes/Norway_Miljodirektoratet_Naturtyper_nin/Original/Naturtyper - Miljødirektoratets instruks/Naturtyper_nin_0000_norge_25833_FILEGDB.gdb', layer="naturtyper_nin_omr") %>%
  # Fix any invalid geometries
  mutate(validGeo = st_is_valid(SHAPE)) %>%
  filter(validGeo) %>%
  # Simplify ecosystem names
  mutate(hovedøkosystem = recode(hovedøkosystem, 
                                 "våtmark" = 'Vaatmark',
                                 "skog" = "Skog",
                                 "fjell" = "Fjell",
                                 "semi-naturligMark" = 'Semi-naturlig',
                                 "naturligÅpneOmråderILavlandet" = 'Naturlig aapne',
                                 "naturligÅpneOmråderUnderSkoggrensa" = 'Naturlig aapne'))

# Transform crs
nin <-st_transform(nin, "EPSG:4326")

# We need to filter out the ecosystems we are not interested in.First, we only include types that are non-alpine by removing the areas that overlap with the bioclimatic zone 'Lavalpin sone (LA)'.
nin <- st_difference(nin, bioclim[bioclim$NAVN == "Lavalpin sone (LA)",])

# Not all alpine types do overlap with this bioclimatic zone due to the resolution of the bioclimatic zone dataset. Thus, we further need to remove these types. In addition, we remove forested wetland types and semi-natural types.
nin <- nin %>%
  filter(!(hovedøkosystem %in% c('Skog','Fjell'))) %>% # Remove forest and alpine ecosystem types
  filter(!(naturtype %in% c('Åpen myrflate i lavalpin sone'))) %>% # Alpine
  filter(!(naturtype %in% c('Hule eiker', # Naturetypes that can have a good condition but has a tree cover >10%
                            'Hagemark',
                            'Lauveng',
                            'Saltpåvirket strand- og sumpskogsmark',
                            'Flommyr, myrkant og myrskogsmark',
                            'Grankildeskog',
                            'Svak kilde og kildeskogsmark',
                            'Sørlig kaldkilde',
                            'Kaldkilde under skoggrensa',
                            'Varmekjær kildelauvskog',
                            'Gammel fattig sumpskog',
                            'Rik gransumpskog',
                            'Rik svartorsumpskog',
                            'Kilde-edellauvskog',
                            'Rik gråorsumpskog',
                            'Kalkrik myr- og sumpskogsmark',
                            'Rik vierstrandskog',
                            'Rik svartorstrandskog',
                            'Saltpåvirket svartorstrandskog',
                            'Leirravine' # This type is often not open
                            ))) %>%
  # Get the main ecosystem codes. As there are multiple types in a column, we need to use a function (see above)
  mutate(hovedtype = sapply(ninKartleggingsenheter, function(x) paste(extract_hovedtype(x), collapse = ",")),
         id = identifikasjon_lokalId) %>%
  # Drop polygons with no condition score
  drop_na(tilstand) %>%
  # Only included specific columns
  dplyr::select(id, hovedøkosystem, hovedtype, naturtypeKode, tilstand)
```

-   **Export the cleaned NiN data and upload to GEE before proceeding**

```{r}
# Only run if you are repeating this workflow for the first time
if(runFromScratch){
nin %>%
   dplyr::select(id, hovedøkosystem, tilstand) %>%
   st_transform("EPSG:4326") %>%
   st_write('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/NiN/nin_cleaned.shp', append=FALSE)
}
```

-   **Now run the following GEE JavaScript code by clicking on the hyperlink:** [GEE script](https://code.earthengine.google.com/25736c6d4f73298e30283ce9b41ab240) (updated script). This script is also found in the SCR repository as "GEE_script.js". When you run the script, then click the Tasks tab in the GEE code editor and run the export tasks. The export files will appear in your Google Drive. Download the files from your Google Drive to the /data/gjengroing/From_GEE directory. This script extracts three CSV files:
    -   'area_cover_grid.csv' - this gives the area coverage of NiN, AR5 and LiDAR data for each 10x10km SSB grid cell.
    -   'elevation_stratified.shp' - this is a 300m elevation band stratification that is simply used for visualizing the strata here in R.
    -   'vegHeights.zip' - this is a folder with hundreds of CSV files. These files contain the vegetation heights for reference, population, and forest polygons over Norway. The exports were split by 50km grid to prevent hitting user memory limits in GEE. Unzip the folder before you upload to ./DATA/From_GEE/

### 7.5 Data from Google Earth Engine

Once you have run the GEE script above, and downloaded the data to the `/From_GEE/` directory, you can proceed with this R workflow.

Create functions to import vegetation height files and stratify data by bioclimatic zone and region.

```{r}
# Function to read in multiple files resulting from GEE exports
readVegHeightFiles <- function(uniqueString){
  dir <- '/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights/'
  files <- list.files(dir)[str_detect(list.files(dir), uniqueString)]
  #print(files)
  
  dat <- tibble()
  for (i in files){
    dat <- dat %>% 
      bind_rows(read_csv(paste0(dir, i)) %>%
                  mutate(ssbid = substr(str_split(i, '_')[[1]][3], 1, 14)))
  }
  return (dat)
}

# Bioclimatic zone lookup
vegLookup <- tibble(
  vegClimZone = c(1,2,3,4,5), 
  vegClimZoneLab = c('Boreonemoral sone (BN)','Lavalpin sone (LA)','Mellomboreal sone (MB)','Nordboreal sone (NB)','Sørboreal sone (SB)')
  )

# Bioclimatic zone and region cleaning function
cleanRegClim <- function(data){
  
  dataOut <- data %>%
    mutate(region=ifelse(region_id == 1, 'Nord-Norge',
                         ifelse(region_id == 2, 'Midt-Norge',
                                ifelse(region_id == 3, 'Østlandet',
                                       ifelse(region_id == 4, 'Vestlandet', 'Sørlandet'))))) %>%

    mutate(vegClimZone = round(vegClimZone)) %>%
    left_join(vegLookup, by = 'vegClimZone') %>%
    dplyr::select(-region_id, -vegClimZone) %>%
    drop_na(vegClimZoneLab, region)
  
  return (dataOut)
  
}
```

If not already done manually, extract files from the zipped GEE folder.

```{r}
zipped_folder <- list.files("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/",
                            pattern=".zip$",full.names=T)
unzipped_folder <- "/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE"

unzip(zipped_folder,exdir=unzipped_folder)


```

Import the CSV files generated in GEE related to area covers and regions

```{r}

# Import data coverages per SSB 10km grid cell
areaCovers <- read_csv('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/area_cover_grid.csv') %>%
  dplyr::select(-'.geo', -'system:index')

# Calculate percentage cover relative to the land area in each cell
areaCoversPerc <- areaCovers %>%
  gather(key, val, vaatmark_pop, aapne_pop, semi_pop, vaatmark_nin, aapne_nin, semi_nin, lidarCover, skog) %>%
  mutate(type = ifelse(str_detect(key, 'pop'), 'pop', 
                       ifelse(str_detect(key, 'nin'), 'nin', 
                              ifelse(key == 'lidarCover', 'lidar', NA)))) %>%
  mutate(ecosystem = ifelse(str_detect(key, 'aapne'), 'Naturlig åpne', 
                       ifelse(str_detect(key, 'vaatmark'), 'Våtmark', 
                              ifelse(str_detect(key, 'semi'), 'Semi-naturlig',NA)))) %>%
  mutate(areaPerc = val/land*100,
         areaPerc = ifelse(is.na(areaPerc), 0, areaPerc)) %>%
  dplyr::select(SSBID, key, type,ecosystem, areaPerc)

```

Import forest heights per region bioclimatic zone combination.

```{r}

skog_region_bioclim <- read_csv("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights_skog_climZoneRegion.csv")

names(skog_region_bioclim)[2:4] <- c("vegClimZone","skog","region_id")

skog_region_bioclim <- skog_region_bioclim %>%
  dplyr::select(-c('system:index','.geo'))

```

Import median population vegetation heights per region-bioclimatic zone combination.

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
    ecosysttype_region_bioclim <- read_csv(paste0("/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/From_GEE/vegHeights/vegHeights_",ecosysttype,"_climZoneRegion.csv"))
    
    names(ecosysttype_region_bioclim)[2:4] <- c("vegClimZone",paste0(ecosysttype,"_pop"),"region_id")
    
    ecosysttype_region_bioclim <- ecosysttype_region_bioclim %>%
  dplyr::select(-c('system:index','.geo'))
    
    assign(paste0(ecosysttype,"_region_bioclim"),ecosysttype_region_bioclim)

}

```

Import the CSV files generated in GEE of vegetation heights (circa 15 min runtime):

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

  
for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
    
    # Import median LiDAR heights for NiN polygons (references)
    refecosysttypeRaw <- readVegHeightFiles(paste0(ecosysttype,'_ref')) %>%
    mutate(ref = chm) %>%
    dplyr::select(-'.geo', -'system:index', -chm)
    
    # Add region and bioclim zones and summarise per strata
    # this will form the upper limit of the ecological condition score (ie. good condition)
  refecosysttype <- cleanRegClim(refecosysttypeRaw) %>%
    group_by(region, vegClimZoneLab) %>%
    summarise(ref = median(ref, na.rm=T))
  
  # Export to file for reference
  refecosysttype %>%
    st_write(paste0('../data/ref',ecosysttype,'.csv'), append=FALSE)
  
  # Import median LiDAR heights for GFA polygons for population measurement
  popecosysttypeHt <- readVegHeightFiles(paste0(ecosysttype,'_pop'))  %>%
    mutate(pop = chm)%>%
    dplyr::select(-chm)
  
  # Turn into spatial objects using the .geo column in the CSV
  popecosysttypeHt <- st_as_sf(bind_cols(popecosysttypeHt,geojsonsf::geojson_sf(popecosysttypeHt$.geo)))
  
  # Combine median LiDAR heights for forest per region and bioclimatic zone combination with population heights.
  # This will form the lower limit of the ecological condition score (ie. poor condition)
  popecosysttype <- popecosysttypeHt %>%
    left_join(skog_region_bioclim, by = c('vegClimZone','region_id'))
  
  # Add region and bioclimatic zone names to the combined population and forest heights
  popecosysttype <- cleanRegClim(popecosysttype)
  assign(paste0('pop',ecosysttype), popecosysttype)
  
  # Combine all the above into one data frame
  set.seed(123)
  ecosysttypeHts <- popecosysttype %>%
    #sample_n(100000) %>%
    as_tibble() %>% dplyr::select(-geometry) %>%
    left_join(refecosysttype, by=c('vegClimZoneLab', 'region')) %>%
    gather(type, height, ref, pop, skog) %>%
    group_by(`system:index`, region, vegClimZoneLab, type) %>%
    summarise(height = mean(height)) %>%
    pivot_wider(values_from = height, names_from = type) %>%
    # If population height is less than the reference value, then it is automatically "good" condition - ie. it inherits the reference height so that the rescaled value will be 1
    mutate(pop = ifelse(pop < ref, ref, pop)) %>%
    drop_na(pop, ref) %>%
    #left_join(ecosysttypeSkogRegionalRef, by = c('vegClimZoneLab', 'region')) %>%
    #mutate(skog = ifelse(is.na(skog), skogFill, skog)) %>%
    #dplyr::select(-skogFill) %>%
    filter(skog < 30)
  #colSums(is.na(ecosysttypeHts))
  
  assign(paste0(ecosysttype,"Hts"), ecosysttypeHts)
  
  st_write(ecosysttypeHts, paste0('../data/', ecosysttype,'hts.csv'), append=FALSE)
  
 }


```

```{r ref-wet-enc, fig.cap="Reference vegetation height in wetland ecosystems under the forest line in Norway."}

refvaatmark  <- read_csv('../data/refvaatmark.csv')

refvaatmark$region <- factor(refvaatmark$region, levels=regionlvl)
refvaatmark$vegClimZoneLab <- factor(refvaatmark$vegClimZoneLab, levels=vegclimzonelvl)

refvaatmark %>%
  ggplot(aes(x = region, y = ref))+
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  theme(axis.text.x = element_text(angle = -45, vjust = 0.5, hjust = 0.2, size = 12))+
  facet_wrap(.~vegClimZoneLab)+
  labs(y = "Reference vegetation height (m)",
       x = " ")
```

```{r ref-open-enc, fig.cap="Reference vegetation height in natural open ecosystems under the forest line in Norway."}

refaapne <- read_csv('../data/refaapne.csv')

refaapne$region <- factor(refaapne$region, levels=regionlvl)
refaapne$vegClimZoneLab <- factor(refaapne$vegClimZoneLab, levels=vegclimzonelvl)

refaapne %>%
  ggplot(aes(x = region, y = ref))+
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  theme(axis.text.x = element_text(angle = -45, vjust = 0.5, hjust = 0.2, size = 12))+
  facet_wrap(.~vegClimZoneLab)+
  labs(y = "Reference vegetation height (m)",
       x = "")
```

```{r ref-semi-enc, fig.cap="Reference vegetation height in semi-natural ecosystems under the forest line in Norway."}

refsemi <- read_csv('../data/refsemi.csv')

refsemi$region <- factor(refsemi$region, levels=regionlvl)
refsemi$vegClimZoneLab <- factor(refsemi$vegClimZoneLab, levels=vegclimzonelvl)

refsemi %>%
  ggplot(aes(x = region, y = ref))+
  geom_bar(stat="identity")+
  theme_bw(base_size = 12)+
  theme(axis.text.x = element_text(angle = -45, vjust = 0.5, hjust = 0.2, size = 12))+
  facet_wrap(.~vegClimZoneLab)+
  labs(y = "Reference vegetation height (m)",
       x = " ")
```

## 8. Spatial units

<!--# Describe the spatial units that you rely on in your analyses. Highlight the spatial units (the resolution) that the indicator values should be interpretted at. Potential spatial delineation data should eb introduced under 7.1. Datasets. We recomend using the SEEA EA terminology opf Basic Spatial Units (BSU), Ecosystem Asses (EA) and Ecosystem Accounting Area (EAA). -->

## 9. Analyses

<!--# Use this header for documenting the analyses. Put code in seperate code chunks, and annotate the code in between using normal text (i.e. between the chunks, and try to avoid too many hashed out comments inside the code chunks). Add subheaders as needed. -->

We will calculate the gjengroing index for each population polygon over Norway using a Sigmoid scaling function.

```{r}

# Define Sigmoid scaling function
scaleSigmoid <- function(variable){
  refLow <- min(variable)
  refHigh <- max(variable)
  thr <- (refHigh-refLow)/2
  indicator_LowHigh <- (variable - refLow)/(refHigh - refLow)
  indicator_LowHigh[indicator_LowHigh[] < 0] <- 0
  indicator_LowHigh[indicator_LowHigh[] > 1] <- 1
  indicator_sigmoid <- 100.68*(1-exp(-5*(indicator_LowHigh)^2.5))/100
  return (round(indicator_sigmoid, 4))
}

```

### 9.1 Subset population data

!! Må her antagelig gjøre delen hvor indikatoren defineres på en subset av populasjonen og at en annen del brukes for å testes på. Tar litt for lang tid å gjøre det for alle dataene og det er også ikke heldig. Kjør en test for hver av typene (våtmark, åpne og semi) for å se hvor mye du må trekke ut for å få en stabil indikator

To reduce run time for calculating indicator values and to XXXX, we will subset the population data. The subset will be balanced throughout the 50 km grid to have a spatially balanced dataset.

An initial test (not shown here) was done for natural open and semi-natural polygons but the enchroachment index did not change depending on number of samples. Thus, we will only subset the wetland population data.

To decide on the number of polygons to use per gridcell, we will calculate the enchroachment index with n number of polygons to get a stable estimate.

```{r}
#| eval: false

ecosysttypes <- c("wetland", "aapne", "semi")

    popecosysttype <- get(paste0('pop',ecosysttype))
  #nrsamples <- unique(round(seq(10, nrow(popecosysttype), length.out=20))) # Proportions to sample
    propsamples <- seq(0.025,1,0.05)
    
    ecosysttypeHts0 <- get(paste0(ecosysttype,'Hts'))
    ecosysttypeHts0 <- ecosysttypeHts0 %>%
        left_join(popecosysttype %>% dplyr::select("system:index", ssbid))


for(i in 1:1){ #for(i in 1:length(ecosysttypes)){
    
    # Nr of samples
    ecosysttype <- ecosysttypes[i]
    popecosysttype <- get(paste0('pop',ecosysttype))
    
    indexGrids <- data.frame(ssbid=ecosysttypeHts0$ssbid)
    
    
    for(n in 1:length(propsamples)){
      print(propsamples[n])
      
      # Sample n population polygons
      set.seed(123)
      ecosysttypeHts <- ecosysttypeHts0 %>% 
        group_by(ssbid) %>% 
        sample_frac(size=propsamples[n]) #sample_n

      # Calculate gjengroing index values
  ecosysttypeIndexPoly <- ecosysttypeHts  %>%
    # Gather into long format so that we can mutate the scaleSigmoid() function
    gather(type, height, ref, pop, skog) %>%
    group_by(`system:index`) %>%
    mutate(index = scaleSigmoid(height)) %>%
    # Because short vegetation is good condition, we must invert the scaled indicator
    mutate(index = 1-index) %>%
    # Get the indicator values for the population polygons only (ref and skog will be 1 and 0)
    filter(type == 'pop') %>%
    dplyr::select(-type, -height) %>%
    # Join with original data to get the actual median vegetation heights for each indicator score
    left_join(ecosysttypeHts %>% dplyr::select("system:index", pop, ref, skog))
  
  # Calculate mean and sd index value per gridcell and save for later
        indexGrid <- ecosysttypeIndexPoly %>% 
        group_by(ssbid) %>% 
        summarise(meangrid=mean(index))
        
        names(indexGrid)[2] <- paste0(names(indexGrid)[2], propsamples[n])
  
        indexGrids <- indexGrids %>%
          left_join(indexGrid)
      
    }
    
    indexGridsT <- data.frame(t(indexGrids))
    names(indexGridsT) <- indexGridsT[1,]
    indexGridsT <- indexGridsT[-1,]
    indexGridsT$nrsamples <- as.numeric(substr(row.names(indexGridsT),9, nchar(row.names(indexGridsT))))
    names(indexGridsT) <- paste0("c",names(indexGridsT))
    
    #require(data.table)
    indexGridsLong <- melt(setDT(indexGridsT), id.vars = "cnrsamples", variable.name = "ssbid")
    indexGridsLong$value <- as.numeric(indexGridsLong$value)

    
    ggplot(indexGridsLong, aes(cnrsamples,value)) +
      #geom_point()
      stat_smooth(method='lm', formula = y~poly(x,2))
      #geom_smooth()

}
```

### 9.2 Scaled indicator values at polygon level (circa \*\*120\*\* min runtime)

!! INSERT TEXT

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
  
    ecosysttypeHts <- get(paste0(ecosysttype,'Hts'))
    popecosysttype <- get(paste0('pop',ecosysttype))

    
  # Calcualte gjengroing index values
  ecosysttypeIndexPoly <- ecosysttypeHts  %>%
    # Gather into long format so that we can mutate the scaleSigmoid() function
    gather(type, height, ref, pop, skog) %>%
    group_by(`system:index`) %>%
    mutate(index = scaleSigmoid(height)) %>%
    # Because short vegetation is good condition, we must invert the scaled indicator
    mutate(index = 1-index) %>%
    # Get the indicator values for the population polygons only (ref and skog will be 1 and 0)
    filter(type == 'pop') %>%
    dplyr::select(-type, -height) %>%
    # Join with original data to get the actual median vegetation heights for each indicator score
    left_join(ecosysttypeHts %>% dplyr::select("system:index", pop, ref, skog)) %>%
    left_join(popecosysttype %>% dplyr::select("system:index", ssbid))
    
  # Make into spatial objects
  ecosysttypeIndexPolySpat <- popecosysttype %>%
    dplyr::select("system:index") %>%
    left_join(ecosysttypeIndexPoly) %>%
    filter(!is.na(index)) %>%
    # Transform to correct projection
    st_transform(st_crs(regions))

  assign(paste0(ecosysttype,"IndexPolySpat"), ecosysttypeIndexPolySpat)
    
}


```

Here we will visualize the spatial variation in scaled gjengroings indicator values, as well as the vegetation heights for reference (good condition), indicator, and mature forest (poor condition) over the country. We could plot all the polygons, but it is computationally intensive and very difficult to visualize spatial variations over the entire country. Therefore we will calculate the area-weighted mean in values for each bioclimatic-region strata (n = XX) over the country.

```{r}

# Create intersection of the two strata layers
bioclim <- st_transform(bioclim, st_crs(regions))
bioClimReg <- bioclim %>%
  st_intersection(regions) %>%
    mutate(vegClimZoneLab = NAVN) %>%
    dplyr::select(region, vegClimZoneLab) %>%
  rowid_to_column("ID")
  
ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    ecosysttype <- ecosysttypes[i]

    if(runFromScratch){
      ecosysttypeIndexPolySpat <- get(paste0(ecosysttype, "IndexPolySpat"))
            # Get area-weighted mean for reference, forest and population vegetation heights 
      # for each unique bioclimatic zone-region combination
      ecosysttypeIndexStrata <- bioClimReg %>% 
        #sample_n(10000) %>%
        st_join(ecosysttypeIndexPolySpat %>% 
                    mutate(area = as.numeric(st_area(geometry))) ,st_intersects) %>%
        group_by(ID) %>%
        summarise_at(vars(pop, ref, skog, index), funs(weighted.mean(., w=area, na.rm=TRUE)))%>% 
        as_tibble() %>% 
        dplyr::select(-geometry)
      
       # Write out for import later
      ecosysttypeIndexStrata %>% write_csv(paste0('../data/',ecosysttype,'IndexStrata.csv'))
      
      assign(paste0(ecosysttype, "IndexStrata"),ecosysttypeIndexStrata)
      
    } 
}


```

### 9.3 Scaled indicator values at 50km grid level (circa 45 min runtime)

"Using the polygon-level indicator scores, we will aggregate to 50km grid level to explore the spatial variation over Norway. We are doing this as an alternative way of visualizing the broad-scale patterns as presented in the section above where we used bioclimatic-elevation strata.

Here we will use a weighted average, but test out the eaTools::ea_spread function! It takes some time to run so best to do this overnight, or to parallelize in some way."

```{r}

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
    
    if (runFromScratch){
      
    ecosysttypeIndexPolySpat <- get(paste0(ecosysttype,'IndexPolySpat'))

    # Aggregate polygon index scores to grid level using eaTools ea_spread function
    ecosysttypeIndexGrid <- eaTools::ea_spread(indicator_data = ecosysttypeIndexPolySpat,
                                            indicator = index,
                                            regions = ssb50km,
                                            groups = SSBID,
                                            threshold = 1) %>%
    mutate(index = w_mean, ssbid = ID) %>%
    dplyr::select(ssbid, index, sd)
  
    # Export
    ecosysttypeIndexGrid %>% st_write(paste0('../data/',ecosysttype,'_index_grid.shp'))
    
    assign(paste0(ecosysttype, "IndexGrid"),ecosysttypeIndexGrid)


    } 
     
}
```

### 9.4 Scaled indicator values at regional level (circa 120 min runtime)

"Now we will aggregate up to the regional level for final reporting. We will use the same method as in the section above, except here we will use a different method to calculate the uncertainty value around the indicator values. The ea_spread function in eaTools uses a bootstrapping method to calculate the standard error in indicator values when aggregating from the polygon to regional level. Because we have hundreds of thousands of polygons per region, the resulting standard errors are extremely small. Therefore we will use the standard deviation in reference values per region. The standard deviation, as a percentage of the average reference value is used to calculate the uncertainty in the scaled indicator value."

```{r}

ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
      ecosysttype <- ecosysttypes[i]

      if (runFromScratch){
  
      # Get the mean population, reference and forest heights per region for interpreting index values
      # The standard deviation is used later to define uncertainty around the indicator score
      ecosysttypeIndexPolySpat <- get(paste0(ecosysttype, "IndexPolySpat"))
      

      ecosysttypeHeightsRegion <- regions %>%
        st_join(ecosysttypeIndexPolySpat) %>% 
        as_tibble() %>%
        drop_na(index) %>%
        # Some errors in column names on the way but region.x and region.y are the same 
        mutate(region=region.x) %>%
        dplyr::select(-region.x, -region.y) %>%
        group_by(region) %>%
        summarise(pop_mean = mean(pop),
                  skog_mean = mean(skog),
                  ref_mean = mean(ref),
                  sd_ref = sd(ref))
  
     # Aggregate polygon index scores to regional level using eaTools
      ecosysttypeIndexRegion <- eaTools::ea_spread(indicator_data = ecosysttypeIndexPolySpat,
                                              indicator = index,
                                              regions = regions,
                                              groups = region,
                                              threshold = 1) %>%
      mutate(index = w_mean, region = ID) %>%
      dplyr::select(region, index, sd) %>%
      left_join(ecosysttypeHeightsRegion)
    
      ecosysttypeIndexRegion %>% st_write(paste0('../data/',ecosysttype,'_index_grid.shp'), append=F)
  
      assign(paste0(ecosysttype, "IndexRegion"),ecosysttypeIndexRegion)
  
  } 
}

```

### 9.4 Validation

Run test on an independent subset of data.

"

The calculation of the indicator involves many small decisions which can have significant effects on the resulting conditions cores. Therefore in the future it would be good to perform sensitivity analyses with each decision to test the effect on the outcome. The decisions which would benefit from further exploration include:

-   **Selection of the reference and population areas.** Here we were limited to using NiN and AR5 because these are arguably the best datasets currently available for this exercise. However, both NiN and AR5 are spatially and thematically biased in some ways. Therefore, it may be worth exploring alternative datasets in the future. NiN polygons are biased towards low lying areas which are generally warmer and more productive. For a given bioclimatic-elevation strata, this could lead to higher reference values for vegetation height than one would expect with a representative reference sample. This could consequently result in high elevation population polygons appearing to have very good condition because they are being compared with (relatively) high productivity polygons in the same bioclimatic-elevation strata. This is a possible explanation for why the high elevation parts of Norway appear to be in very good ecological condition.

-   **Definition of good condition states in NiN data.** Here we used the overall "tilstand" score for each NiN reference polygon. However, the overall score is a combination of several sub-scores that may or may not be relevant for ecological condition. For instance, ditches or wheel marks in wetlands is a common condition score in NiN, however it is debatable as to whether this should be considered a part of ecological condition. Therefore it may be beneficial to attempt repeating the indicator calculation using sub-categories of "tilstand" in the NiN data.

-   **Definition of climax successional stage for tree regrowth.** Here we use the 50th percentile of LiDAR-derived tree heights in AR5 forest polygons that have not been harvested since 1986. This defines the zero on the scaled indicator score. The resulting indicator scores will vary widely depending on how you define this zero-point. Therefore, testing different definitions (i.e. tree height percentiles) may be important.

-   **Quantifying regional vs local references for poor and good condition.** For good condition, we used NiN polygons and were restricted to these due to lack of better data. However, for poor condition we use climax successional stage for trees (as explained above) within 200m of each population polygon. For polygons with no surrounding forest, we impute with regional reference values (mean of forest height in elevation-bioclamic zone). The choice of 200m buffer zone was largely based on computational limitations. Calculating the average LiDAR vegetation height within 200m of nearly 2 million complex polygons takes time, even in GEE. It may make more ecological sense to define a larger buffer zone to use for defining reference for poor condition. However, longer processing times need to be expected.

-   **Quantification of uncertainty around indicator scores.** Here we used the standard deviation in the vegetation heights for reference (NiN) polygons within each region to quantify the uncertainty around scaled indicator scores. We did this because the method used in `eaTools::ea_spread()` function is a bootstrapping approach which resulted in extremely small uncertainty estimates due to the large number of polygons included in our analysis. [In the future, a better method for quantifying uncertainty is needed.](https://github.com/NINAnor/eaTools/issues/17) Perhaps by running sensitivity analyses that test several variations of the points mentioned above can form the basis for quantifying an error margin around indicator values.

"

## 10. Results

<!--# Repeat the final results here. Typically this is a map or table of indicator values.-->

### 10.1 Scaled indicator values at polygon level

```{r multiple-maps-enc, fig.width=10, fig.cap="Maps of scaled and unscaled indicator values, as well as reference values. For the unscaled variables the legend is truncated at 5 m to ensure the same colour gradient for all maps."}
  
# Import datasets
ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    ecosysttype <- ecosysttypes[i]

    ecosysttypeIndexStrata <- read_csv(paste0('../data/',ecosysttype,'IndexStrata.csv'))
    
    assign(paste0(ecosysttype, "IndexStrata"),ecosysttypeIndexStrata)    
}


# Make plots of indicator heights and scaled condition values for each strata polygon

theme_legend_1 <- theme(legend.key.size = unit(0.25, 'cm'), #change legend key size
                        legend.key.height = unit(0.25, 'cm'), #change legend key height
                        legend.key.width = unit(0.25, 'cm'), #change legend key width
                        legend.title = element_text(size=6), #change legend title font size
                        legend.text = element_text(size=6)) #change legend text font size

makeStrataHeightMap <- function(data, var, title, limits){
  p <- bioClimReg %>%
    left_join(data, by = c('ID'))  %>%
    mutate(response = .[[var]]) %>%
    ggplot() + 
    geom_sf(aes(fill = response), color=NA)+
      scale_fill_gradientn(colors=viridis::viridis(10),
                           limits = limits,
                           oob = scales::squish,
                           name = 'Veg ht (m)')+
      ggtitle(title) +
      theme_void() +
    theme(plot.title = element_text(size=9)) +
    theme_legend_1
    
  return (p)
}

makeStrataIndicatorMap <- function(data, title){
  p <- bioClimReg %>%
    left_join(data, by = c('ID'))  %>%
    ggplot() + 
    geom_sf(aes(fill = index), color=NA)+
      scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                           limits = c(0,1),
                           name = 'Index')+
      ggtitle(title) +
      theme_void()+
    theme(plot.title = element_text(size=9)) +
    theme_legend_1
    
  return (p)
}

v1 <- makeStrataIndicatorMap(vaatmarkIndexStrata, 'A) Våtmark scaled indicator')
v2 <- makeStrataHeightMap(vaatmarkIndexStrata, "ref", 'B) Våtmark reference height', c(0,5))
v3 <- makeStrataHeightMap(vaatmarkIndexStrata, "pop", 'C) Våtmark indicator height', c(0,5))
v4 <- makeStrataHeightMap(vaatmarkIndexStrata, "skog", 'D) Mature forest height', c(0,5))

a1 <- makeStrataIndicatorMap(aapneIndexStrata,  'E) Naturlig åpne scaled indicator')
a2 <- makeStrataHeightMap(aapneIndexStrata, "ref", 'F) Naturlig åpne reference height', c(0,5))
a3 <- makeStrataHeightMap(aapneIndexStrata, "pop", 'G) Naturlig åpne indicator height', c(0,5))
a4 <- makeStrataHeightMap(aapneIndexStrata, "skog", 'H) Naturlig åpne forest height', c(0,5))

s1 <- makeStrataIndicatorMap(semiIndexStrata,  'I) Semi-naturlig scaled indicator')
s2 <- makeStrataHeightMap(semiIndexStrata, "ref", 'J) Semi-naturlig reference height', c(0,5))
s3 <- makeStrataHeightMap(semiIndexStrata, "pop", 'K) Semi-naturlig indicator height', c(0,5))
s4 <- makeStrataHeightMap(semiIndexStrata, "skog", 'L) Semi-naturlig forest height', c(0,5))


strataHeightPlot <- grid.arrange(v1,v2,v3,v4,
                                 a1,a2,a3,a4, 
                                 s1,s2,s3,s4, 
                                 ncol=4, widths=c(1,1,1,1), padding = unit(0, "line"), newpage = T) 

```

### 10.2 Scaled indicator values at 50km grid level

```{r grid-level-enc, fig.cap="Maps displaying scaled encroachment indicator values on a 50 km grid level"}

print('Will import pre-exported data')

ecosysttypes <- c("vaatmark", "aapne", "semi")

for(i in 1:length(ecosysttypes)){
    
    ecosysttype <- ecosysttypes[i]
  
    ecosysttypeIndexGrid <- st_read(paste0('../data/',ecosysttype,'_index_grid.shp')) 
  
    assign(paste0(ecosysttype, "IndexGrid"),ecosysttypeIndexGrid)
     
}

vGrid1 <- vaatmarkIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('A) Våtmark gjengroing condition')

vGrid2 <- aapneIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('B) Naturlig åpne gjengroing condition')

vGrid3 <- semiIndexGrid %>%
  ggplot() +
  geom_sf(aes(fill=index), color=NA) +
  geom_sf(data=regions, fill=NA, size=0.5) +
  scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                       limits = c(0,1),
                       name = 'Index') +
  theme_void() +
  theme(legend.position = c(0.7, 0.4),
        plot.title = element_text(size=10)) +
  ggtitle('C) Semi-naturlig condition')



indexGridFig <- grid.arrange(vGrid1, vGrid2, vGrid3, ncol=3, widths=c(1,1,1),
                             padding = unit(0, "line"), newpage = T) 

```

### 10.3 Scaled indicator values at regional level

Present the indicator values as table, plots, and maps:

```{r regional-level-enc, fig.cap="Maps displaying scaled encroachment indicator values on a regional level"}

print('Will import pre-exported data')

ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
      ecosysttype <- ecosysttypes[i]
  
      ecosysttypeIndexRegion <- st_read(paste0('../data/',ecosysttype,'_index_grid.shp'))
  
      assign(paste0(ecosysttype, "IndexRegion"),ecosysttypeIndexRegion)
}

# Join into a table to present values
vaatmarkTable <- vaatmarkIndexRegion %>% as_tibble() 
aapneTable <- aapneIndexRegion %>% as_tibble() 
semiTable <- semiIndexRegion %>% as_tibble() 

aapneTable %>% mutate(Ecosystem = 'Naturlig åpne')

# Join ecosystem types and calculate uncertainty
indicatorTable <- vaatmarkTable %>% mutate(Ecosystem = 'Våtmark') %>%
  bind_rows(aapneTable %>% mutate(Ecosystem = 'Naturlig åpne')) %>%
  bind_rows(semiTable %>% mutate(Ecosystem = 'Semi-naturlig')) %>%

  # Calculate the error based on the standard deviation in reference polygon heights
  # as a percentage of the reference height, and multiply by index score
  mutate(sd = (sd_ref/ref_mean)*index)

# Format the table for presentation
indicatorTable_formatted <- regions %>%
  left_join(indicatorTable) %>% as_tibble() %>%
  dplyr::select(-geometry)  %>%
  dplyr::select( region, Ecosystem, index, sd, pop_mean, ref_mean, skog_mean) %>%
  mutate_if(is.numeric, round, 2)
names(indicatorTable_formatted) <- c( "Region", "Ecosystem",
                                      "Scaled indicator",  "Scaled Std.dev",
                                      "Indicator height","Reference height",
                                      "Mature forest height")

# Use knitr to visualize
knitr::kable(indicatorTable_formatted)

# Make plots of regional index values
getIndicatorPlot <- function(label){
  regions %>%
    left_join(indicatorTable %>%
                filter(Ecosystem == label)) %>%
    mutate(lowError = index-sd, 
           upError = index+sd,
           upError = ifelse(upError > 1, 1, upError)) %>%
    ggplot(aes(y=region, x=index)) +
    geom_point() +
    geom_segment(aes(yend=region, x=lowError, xend=upError)) +
    coord_cartesian(xlim=c(0,1)) +
    geom_vline(xintercept = 1) +
    geom_vline(xintercept = 0) +
    labs(x = 'Tilstandsverdi') +
    theme(axis.title.y=element_blank()) +
    ggtitle(label) 
}

i1 <- getIndicatorPlot('Våtmark')
i2 <- getIndicatorPlot('Naturlig åpne')
i3 <- getIndicatorPlot('Semi-naturlig')

indicatorGraphFig <- grid.arrange(i1, i2, i3, ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 

# Make maps of regional index values
getIndicatorMap <- function(data, label){
  regions %>%
    left_join(data) %>%
    ggplot() +
    geom_sf(aes(fill=index)) +
    scale_fill_gradientn(colors=brewer.pal(10, 'Spectral'),
                         limits = c(0,1))+
    ggtitle(label)+
    theme_void()
}

m1 <- getIndicatorMap(vaatmarkTable, 'A) Våtmark')
m2 <- getIndicatorMap(aapneTable, 'B) Naturlig åpne')
m3 <- getIndicatorMap(semiTable, 'C) Semi-naturlig')

indicatorGMapFig <- grid.arrange(m1, m2, m3, ncol=3, widths=c(1,1,1), padding = unit(0, "line"), newpage = T) 
```

"From these tables, figures and maps we can see that the gjengroing condition indicator scores are on average above 0.8 and therefore indicate a good overall condition in Norway. Østlandet comes out best for våtmark and semi-naturlig åpne ecosystems. Nord-Norge has poorest condition for semi-naturlig åpne ecosystems, while vestlandet has the poorest scores for våtmark."

### 10.5 Uncertainty and validation

## 11. Export file

<!--# Display the code (don't execute it) or the workflow for exporting the indicator values to file. Ideally the indicator values are exported as a georeferenced shape or raster file with indicators values, reference values and errors. You can also chose to export the raw (un-normalised or unscaled variable) as a seperate product. You should not save large sptaial output data on GitHub. You can use eval=FALSE to avoid code from being executed (example below - delete if not relevant) -->

"We will export gjengroing indicator values at three levels: - polygon level - 50km grid level - regional level"

```{r export}
#| eval: false

ecosysttypes <- c("vaatmark", "aapne","semi")
  
for(i in 1:length(ecosysttypes)) {
    
    ecosysttype <- ecosysttypes[i]
      
    # Polygon level
    ecosysttypeIndexPolySpat <- get(paste0(ecosysttype,"IndexPolySpat"))
    ecosysttypeIndexPolySpat  %>%
    #mutate(area = as.numeric(st_area(geometry)))%>% 
    #filter(area > 7500) %>%
    mutate(id = `system:index`,
           region = region, 
           vegZn = vegClimZoneLab) %>%
    dplyr::select(-"system:index", -vegClimZoneLab, -elevation) %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index.shp"), append=FALSE)
      
    # Grid level
    ecosysttypeIndexGrid <- get(paste0(ecosysttype,"IndexGrid"))
    ecosysttypeIndexGrid %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index_grid.shp"), append=FALSE)
      
    # Region level
    ecosysttypeIndexRegion <- get(paste0(ecosysttype,"IndexRegion"))
    ecosysttypeIndexRegion %>%
    st_write(paste0('/data/P-Prosjekter2/412421_okologisk_tilstand_2024/Ida/Export/', ecosysttype,"_index_region.shp"), append=FALSE)
      

}
```
