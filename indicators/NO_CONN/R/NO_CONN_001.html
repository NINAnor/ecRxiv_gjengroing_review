<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.543">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Connectivity</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="NO_CONN_001_files/libs/clipboard/clipboard.min.js"></script>
<script src="NO_CONN_001_files/libs/quarto-html/quarto.js"></script>
<script src="NO_CONN_001_files/libs/quarto-html/popper.min.js"></script>
<script src="NO_CONN_001_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="NO_CONN_001_files/libs/quarto-html/anchor.min.js"></script>
<link href="NO_CONN_001_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="NO_CONN_001_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="NO_CONN_001_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="NO_CONN_001_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="NO_CONN_001_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="NO_CONN_001_files/libs/tabwid-1.1.3/tabwid.css" rel="stylesheet">
<script src="NO_CONN_001_files/libs/tabwid-1.1.3/tabwid.js"></script>


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Connectivity</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p><em>IndicatorID</em>: NO_CONN_001</p>
<p><em>Norwegian name</em>: Konnektivitet</p>
<p><em>Author and date:</em> Vegar Bakkestuen, November 2023</p>
<!-- Load all you dependencies here -->
<!-- Fill in which ecosystem the indicator belongs to, as well as the ecosystem characteristic it should be linked to. It's OK to use some Norwegian here -->
<div class="cell">
<div class="cell-output-display">
<div class="tabwid"><style>.cl-306a8edc{table-layout:auto;}.cl-305ba34a{font-family:'Arial';font-size:11pt;font-weight:bold;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-305ba368{font-family:'Arial';font-size:11pt;font-weight:normal;font-style:normal;text-decoration:none;color:rgba(0, 0, 0, 1.00);background-color:transparent;}.cl-3061b960{margin:0;text-align:left;border-bottom: 0 solid rgba(0, 0, 0, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);padding-bottom:5pt;padding-top:5pt;padding-left:5pt;padding-right:5pt;line-height: 1;background-color:transparent;}.cl-3061d80a{background-color:rgba(173, 216, 230, 1.00);vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 1.5pt solid rgba(102, 102, 102, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}.cl-3061d814{background-color:transparent;vertical-align: middle;border-bottom: 1.5pt solid rgba(102, 102, 102, 1.00);border-top: 0 solid rgba(0, 0, 0, 1.00);border-left: 0 solid rgba(0, 0, 0, 1.00);border-right: 0 solid rgba(0, 0, 0, 1.00);margin-bottom:0;margin-top:0;margin-left:0;margin-right:0;}</style><table data-quarto-disable-processing="true" class="cl-306a8edc"><thead><tr style="overflow-wrap:break-word;"><th class="cl-3061d80a"><p class="cl-3061b960"><span class="cl-305ba34a">Ecosystem</span></p></th><th class="cl-3061d80a"><p class="cl-3061b960"><span class="cl-305ba34a">Økologisk egenskap</span></p></th><th class="cl-3061d80a"><p class="cl-3061b960"><span class="cl-305ba34a">ECT class</span></p></th></tr></thead><tbody><tr style="overflow-wrap:break-word;"><td class="cl-3061d814"><p class="cl-3061b960"><span class="cl-305ba368">Våtmark</span></p></td><td class="cl-3061d814"><p class="cl-3061b960"><span class="cl-305ba368">Landskapsøkologiske mønstre</span></p></td><td class="cl-3061d814"><p class="cl-3061b960"><span class="cl-305ba368">Landscape and seascape characteristics</span></p></td></tr></tbody></table></div>
</div>
</div>
<!-- Don't remove these three html lines -->
<p><br> <br></p>
<hr>
<!-- Document you work below. Try not to change  the headers too much. Data can be stored on NINA server. Since the book is rendered on the R Server this works fine, but note that directory paths are different on the server compared to you local machine. If it is not too big you may store under /data/ on this repository -->
<section id="intro-con" class="level2">
<h2 class="anchored" data-anchor-id="intro-con">Introduction</h2>
<p>Loss of natural habitat and changes in landscape patterns are central issues in biogeography and conservation biology. The loss of connectivity (connections or linkages) between suitable habitats affects individuals, populations, and communities through various ecosystem interactions. In landscape ecology, connectivity is essentially defined as “the degree to which the landscape facilitates or impedes movement between patches of resources or suitable habitats.” The concept of connectivity encompasses both structural connectivity, which involves the physical locations of suitable and unsuitable habitats or patches being analyzed, and functional connectivity, which focuses on the actual movement of individuals across suitable and unsuitable habitats and disturbance barriers. We have assessed that there is currently insufficient data available to start calculating functional connectivity on a national scale in relation to the assessment of ecological condition, as there is almost a total lack of relevant data for almost all species. Therefore, we have developed an index for structural connectivity based on physical interventions calculated using an infrastructure index (Erikstad et al.&nbsp;2023) and a new wetland map for Norway (Bakkestuen et al.&nbsp;2023, Bakkestuen et al.&nbsp;in prep).</p>
<p>Here a general workflow for the calculation of the indicator.</p>
<ol type="1">
<li>You must load the necessary libraries for geospatial analysis.</li>
<li>You must load the infrastructure index and wetland data.</li>
<li>You define the buffer distance (500 meters).</li>
<li>You must create a function (<code>calculateMeanDistance</code>) to calculate the mean distance to infrastructure within a buffer around each wetland polygon.</li>
<li>Then you filter and keep only the homogeneous wetlands with more than 80% probability in the AI model for mire coverage.</li>
<li>You have to apply the <code>calculateMinimumnDistance</code> function to these selected wetlands, both with and without infrastructure.</li>
<li>You export the results as shapefiles for both scenarios.</li>
<li>The scaled values for the “Connectivity” indicator are determined by comparing two scenarios: one that includes the presence of infrastructure and one that excludes infrastructure. The reference value is calculated as the ratio of the mean distances between myrpolygon areas in these two scenarios.</li>
</ol>
<p>Currently step 8, and a subsequent step 9 (to aggregate scaled indicators to regions and simultaneously calculate errors) are not complete. Se <a href="">this issue</a>https://github.com/NINAnor/ecosystemCondition/issues/144.</p>
<p>It is also possible to create a time series for this indicator, but this is not yet done. See <a href="https://github.com/NINAnor/ecosystemCondition/issues/145">GitHub issue</a>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">include_graphics</span>(<span class="st">"../img/conectivity-concept.png"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="../img/conectivity-concept.png" class="img-fluid figure-img" width="566"></p>
<figcaption>Conceptual model for the calculation of the conectivity indicator. Two distances are calculated: one from the centre point of one mire polygon to the closest neighbouring polygon (green arrow = the reference value), and one from the same centre point to the closest infrastructure (red arrow = area with infrastructure index value above 3). The scaled indicator is the ratio, or quotient, of the length of the red arrow divided by the length of the green arrow.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="underlying-data-con" class="level2">
<h2 class="anchored" data-anchor-id="underlying-data-con">About the underlying data</h2>
<p>The <strong>infrastructure index</strong> is one part of the connectivity index for wetlands. The infrastructure index was calculated for three time points: 2003, 2013, and 2023. This provides a temporal perspective for assessing changes over time. The data used included information on various types of infrastructure, such as roads and buildings. Additionally, a <strong>new wetland</strong> map for Norway has been developed. This map is based on Sentinel-2 and LiDAR data from the year 2020. The U-Net model, implemented through Google Earth Engine and TensorFlow, has been used for mapping wetlands in southern Norway. The model achieved a balanced accuracy rate of 90.9% when validated against ground-truth samples, significantly improving upon the accuracy rates achieved with manually digitized maps in Norway.</p>
<section id="representativity-con" class="level3">
<h3 class="anchored" data-anchor-id="representativity-con">Representativity in time and space</h3>
<p>The data for the infrastructure index covers the entire country and was collected for three time points over a 20-year period. This provides a broad and representative dataset for assessing changes in connectivity in Norwegian landscapes. The wetland mapping was conducted using data from the year 2020, making it representative for that specific time frame. However, the model used in the mapping process can be applied to other time frames if necessary.</p>
</section>
<section id="units-con" class="level3">
<h3 class="anchored" data-anchor-id="units-con">Original units</h3>
<p>The infrastructure index has no specific units as it is a measure of landscape fragmentation and disruption. It is expressed as a dimensionless index.</p>
</section>
<section id="temporal-coverage-con" class="level3">
<h3 class="anchored" data-anchor-id="temporal-coverage-con">Temporal coverage</h3>
<p>The data covers three time points: 2003, 2013, and 2023. This provides a 20-year temporal perspective for assessing changes in connectivity over time. The wetland mapping provides information in the form of pixel values representing wetland presence or absence.</p>
</section>
<section id="additional-comments-con" class="level3">
<h3 class="anchored" data-anchor-id="additional-comments-con">Aditional comments about the dataset</h3>
<p>It is important to note that infrastructure data are based on available map and geographical data sources. Sometimes, there may be variations and uncertainties in this data that can affect the accuracy of the infrastructure index.</p>
</section>
</section>
<section id="egenskap-con" class="level2">
<h2 class="anchored" data-anchor-id="egenskap-con">Ecosystem characteristic</h2>
<p>In the context of the Norwegian standard, the “Connectivity” indicator aligns with the ecosystem characteristic known as <strong>Landskapsøkologiske mønstre</strong>.</p>
<section id="seea-con" class="level3">
<h3 class="anchored" data-anchor-id="seea-con">SEEA EA (UN standard)</h3>
<p>In the framework of the United Nations System of Environmental-Economic Accounting (SEEA EA), the <em>Connectivity</em> indicator can be classified as a <strong>C1 Landscape and seascape characteristics</strong> indicator.</p>
</section>
</section>
<section id="collinear-con" class="level2">
<h2 class="anchored" data-anchor-id="collinear-con">Collinearities with other indicators</h2>
<p>Connectivity is not thought to exhibit collinearity with any other indicator at the present.</p>
</section>
<section id="ref-conditions-and-values-con" class="level2">
<h2 class="anchored" data-anchor-id="ref-conditions-and-values-con">Reference condition and values</h2>
<section id="ref-condition-con" class="level3">
<h3 class="anchored" data-anchor-id="ref-condition-con">Reference condition</h3>
<p>The reference condition for the “Connectivity” indicator is characterized as one with minimal negative human impact on the connectivity of ecosystems. In this reference condition, the landscape exhibits natural and undisturbed patterns of connectivity between suitable habitats. This state represents the optimal ecological condition for connectivity assessment.</p>
</section>
<section id="ref-values-con" class="level3">
<h3 class="anchored" data-anchor-id="ref-values-con">Reference values, thresholds for defining <em>good ecological condition</em>, minimum and/or maximum values</h3>
<p>The reference values for the “Connectivity” indicator are determined by calculating the connectivity or mean distance to mire polygons, when excluding infrastructure from the analysis.</p>
<p>In the report «Vurdering av økologisk tilstand for fjell i Norge i 2021» (Framstad et al.&nbsp;2021) the value of 0,6 was used as the threshold for good ecological condition. We will tentatively use this threshold value again here. A perpetual discussion about the reference (and threshold values) for the connectivity indicator is maintained on <a href="https://github.com/NINAnor/ecosystemCondition/issues/143">GitHub.</a></p>
</section>
</section>
<section id="uncertainties-con" class="level2">
<h2 class="anchored" data-anchor-id="uncertainties-con">Uncertainties</h2>
<p>Our wetland mapping model is a powerful tool for large-scale mapping but does come with certain uncertainties. While our U-Net model achieved an impressive balanced accuracy rate of 90.9% when validated against an independent ground-truth sample, it’s essential to recognize that some level of uncertainty is inherent. The model’s accuracy may vary across different wetland types and landscape conditions. The model’s performance might vary in regions with distinct wetland characteristics that differ from our training data. It may not fully capture variations in wetland types or subtle differences in wetland boundaries. The accuracy of the wetland mapping model is influenced by the quality and representativeness of the training data. We made significant efforts to ensure the highest quality, but the inherent variability in ground-truth data may introduce some level of uncertainty.</p>
<p>The infrastructure data sources used for this analysis might contain inaccuracies, errors, or omissions. These can arise from factors like inconsistent reporting and data collection methods. While infrastructure data is a valuable proxy for landscape barriers, it may not capture all potential barriers accurately. For instance, small-scale features or unreported structures could introduce uncertainties in connectivity assessments. The resolution of the infrastructure data might not capture all relevant features at a fine scale. This can affect the precision of connectivity assessments in areas with small, localized infrastructure.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p>Bakkestuen, V.; Venter, Z.; Ganerød, A.J.; Framstad, E. Delineation of Wetland Areas in South Norway from Sentinel-2 Imagery and LiDAR Using TensorFlow, U-Net, and Google Earth Engine. Remote Sens. 2023, 15, 1203. https://doi.org/10.3390/rs15051203</p>
<p>Bakkestuen, V. et al.&nbsp;in prep. Comprehensive Mapping of Wetland Areas in Norway: An Integration of Sentinel-2 Imagery, LiDAR, and Deep Learning Using TensorFlow and Google Earth Engine</p>
<p>Erikstad, L.; Simensen, T.; Bakkestuen, V.; Halvorsen, R. Index Measuring Land Use Intensity—A Gradient-Based Approach. Geomatics 2023, 3, 188-204. https://doi.org/10.3390/geomatics3010010</p>
<p>Framstad, E., Eide, N.E., Eide, W., Klanderud, K., Kolstad, A., Töpper, J. &amp; Vandvik, V. 2022. Vurdering av økologisk tilstand for fjell i Norge i 2021. NINA Rapport 2050. Norsk institutt for naturforskning.</p>
</section>
<section id="analyses-con" class="level2">
<h2 class="anchored" data-anchor-id="analyses-con">Analyses</h2>
<section id="datasets-con" class="level3">
<h3 class="anchored" data-anchor-id="datasets-con">Data sets</h3>
<p>Two main data sets were included.</p>
<p>A. The infrastructure index (Erikstad et al.&nbsp;2023) and;</p>
<p>B. The wetland model (Bakkestuen et al.&nbsp;2023, Bakkestuen et al.&nbsp;<em>In prep.</em>)</p>
<section id="data-a-con" class="level4">
<h4 class="anchored" data-anchor-id="data-a-con">Data set A - Infrastructure index</h4>
<p>The infrastructure index utilized in this analysis was derived from data sources available through Google Earth Engine (GEE). The index quantifies the presence and distribution of key infrastructure elements such as roads, buildings, and related human-made structures across Norway. The data were available for the years 2003, 2013, and 2023, facilitating an assessment of how infrastructure has evolved in terms of both magnitude and distribution over time. It is important to note that this data forms a fundamental component in the calculation of the connectivity indicator.</p>
</section>
<section id="data-b-con" class="level4">
<h4 class="anchored" data-anchor-id="data-b-con">Data set B - Wetland model</h4>
<p>The wetland model used in this study was developed based on the integration of Sentinel-2 satellite imagery and LiDAR data, utilizing deep learning techniques. The model provides high-resolution information regarding the distribution and extent of wetland areas within southern Norway, specifically for the year 2020. By fusing spectral and elevation data, this model offers significant improvements over conventional, manually-digitized land cover maps. The wetland model is a critical component of the connectivity analysis, as it aids in the identification of ecologically relevant areas. The data set B for South-Norway is already accessible <a href="https://kartkatalog.geonorge.no/metadata/aapen-vtmark-i-soer-norge-basert-p-natur-i-norge-nin-typologi/6b5a34f9-c23d-4cca-a51b-01251c217cb1">here</a>.</p>
</section>
</section>
<section id="scaled-values-con" class="level3">
<h3 class="anchored" data-anchor-id="scaled-values-con">Scaled indicator values</h3>
<p>The connectivity indicator was created by examining the interplay between infrastructure and wetland areas. We initially calculated the average distance between wetland patches using the wetland model, representing a baseline measure of natural connectivity in the absence of infrastructure (i.e., the reference condition). Subsequently, the infrastructure index was introduced, portraying the extent of human-made structural elements within the landscape. The scaled indicator is the quotient of the values.</p>
</section>
<section id="uncertainty-con" class="level3">
<h3 class="anchored" data-anchor-id="uncertainty-con">Uncertainty</h3>
<p>The current state of the indicator is as a geospatial data set with one scaled indicator value per mire polygon, and no errors around this value. Future improvement must include aggregating these indicator values to regions. The uncertainties around these aggregated indicator values could then be represented by the spatial variation in the indicator values.</p>
</section>
</section>
<section id="pre-export-con" class="level2">
<h2 class="anchored" data-anchor-id="pre-export-con">Prepare export</h2>
<p>You must run the whole code below. There is an approximately maximum of 50000 wetland polygons or 60-70 MB shapefile for each export. The whole of Norway is exported in 25 tiles.</p>
<section id="java-con" class="level3">
<h3 class="anchored" data-anchor-id="java-con">JAVA code</h3>
<p>Koden er utviklet i JAVA for Google Earth Engine:</p>
<pre><code>// Laste inn myr datasett fra Google Earth Engine Data
var myrpred2 = ee.ImageCollection('users/vegarbakkestuen/Myr168NN');
var myr = myrpred2.min();

// Laste inn infrastrukturindeks fra Google Earth Engine Data
var infrastruktur = ee.Image('users/vegar/NY_INFRA_IND');

// Konverter infrastruktur til en vektorbasert maske med terskelverdi 2
var infrastrukturMask = infrastruktur.gt(2);

// Masker infrastrukturen med myrpolygonene
var maskedInfra = infrastrukturMask.mask(infrastrukturMask);

// Definer en bufferavstand (i meter) som bestemmer området som blir analysert rundt hvert myrpolygon
var bufferDistance = 1000;

// Funksjon for å beregne minimum avstand mellom myrer og infrastruktur innenfor samme datasett
var calculateMinimumDistance = function (feature) {
  // Beregn avstanden til nærmeste nabo-myrene ved å bruke map-funksjonen
  var minDistanceToMyr = ee.FeatureCollection(omraderMedMyrFC)
    .filter(ee.Filter.neq('system:index', feature.get('system:index')))
    .map(function (neighbor) {
      var distanceToMyr = feature.geometry().distance(neighbor.geometry(), bufferDistance);
      return ee.Feature(null, {'distance_to_myr': distanceToMyr});
    });

  // Finn den minimale avstanden til myr ved å sortere samlingen
  minDistanceToMyr = minDistanceToMyr.sort('distance_to_myr');

  // Hent den minimale avstanden til myr fra den første funksjonen i samlingen
  var minDistanceToMyrValue = ee.Number(minDistanceToMyr.first().get('distance_to_myr'));

  // Konverter infrastrukturen til en vektorbasert maske
  var infraVector = maskedInfra.reduceToVectors({
    geometry: feature.geometry().buffer(bufferDistance), // Bruk buffer rundt myrpolygonet
    scale: 10,  // Oppløsningen til datasettet (meters per piksel)
    maxPixels: 1e13
  });

  // Beregn avstanden til infrastruktur ved å finne avstanden til nærmeste nabo i infrastrukturen
  var distanceToInfra = feature.geometry().distance(infraVector.geometry(), bufferDistance);

  // Legg til avstandsverdiene som egenskaper
  feature = feature.set({
    'min_myr_distance': minDistanceToMyrValue,
    'min_infra_distance': distanceToInfra,
    'kvotient': distanceToInfra.divide(minDistanceToMyrValue)
  });

  return feature;
};

// Velg områder med myr (myrinnhold &gt; 80%) og bruk dette som geometri for analysen
var omraderMedMyr = myr.gt(0.8).selfMask();

// Hent geometriene for hvert område med myr
var omraderMedMyrFC = omraderMedMyr.reduceToVectors({
  geometry: geometry, // Bruk den definerte geometrien
  scale: 10,  // Oppløsningen til datasettet (meters per piksel)
  maxPixels: 1e13
});

// Bruk funksjonen calculateMinimumDistance for å beregne minimum avstand til nærmeste nabo-myr og infrastruktur
var omraderMedMinimumDistance = omraderMedMyrFC.map(calculateMinimumDistance);

// Legg til lag som viser myrpolygonene og lag med minimum avstand til nærmeste nabo-myr og infrastruktur på kartet
Map.addLayer(omraderMedMyr, { min: 0, max: 1, palette: ['white', 'green'] }, 'Myrpolygoner');
Map.addLayer(infrastruktur, { min: 0, max: 1, palette: ['white', 'blue'] }, 'infra');
Map.addLayer(omraderMedMinimumDistance, { min: 0, max: 500, palette: ['blue', 'yellow', 'red'] }, 'Minimum avstand til nærmeste nabo-myr');

// Eksporter resultatene som en Shapefile til Google Drive
Export.table.toDrive({
  collection: omraderMedMinimumDistance,
  description: 'Minimum_avstand_til_myr_infrastruktur',
  fileFormat: 'SHP',
});</code></pre>
<p>The scaled “Connectivity” values are created by dividing the result without infrastructure by the result that includes infrastructure. This ratio will give you a value between 0 and 1, where 0 represents complete disruption of connectivity due to infrastructure, and 1 represents undisturbed natural connectivity.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>